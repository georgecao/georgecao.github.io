<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>REPLoop</title>
        <link>https://www.reploop.org</link>
        <atom:link href="https://www.reploop.org/feed.xml" rel="self" type="application/rss+xml"/>
        <description>REPLoop，在脚本编程语言中经常能看到REPL，也就是Read-Evaluate-Print-Loop，意思是读取源代码，评估执行，打印结果的循环。这个过程能够快速的学习实践然后得到结果。非常像一个学习成长的过程：输入信息，消化吸收，输出知识并用于实践，然后持之以恒的坚持。4个环节缺一不可，而且最难做到的大概是持之以恒了。</description>
        <language>en-gb</language>
        <pubDate>Mon, 14 Mar 2022 17:02:46 +0800</pubDate>
        <lastBuildDate>Mon, 14 Mar 2022 17:02:46 +0800</lastBuildDate>

            <item>
                <title>基本会计概念2-借记与贷记</title>
                <link>https://www.reploop.org/blog/2022/03/basic-accounting-concepts-2-debits-and-credits.html</link>
                <pubDate>Thu, 3 Mar 2022 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2022/03/basic-accounting-concepts-2-debits-and-credits.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这是一个帮你理解借记与贷记这两个会计概念的教程。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;大多数人认为会计涉及的数学不像理解会计概念那么难，而会计概念中最难理解掌握的2个就是借记与贷记。 现在借记和贷记的概念实际上已有500多年的历史，早在15世纪文艺复兴时期就被意大利威尼斯商人广泛使用。 这两个概念最早是在14世纪用拉丁文记载的，并在16世纪翻译为英语。随着500年的过去，我们可能对最初的含义和概念有些困惑，特别是英语对这些古老的词语采用了新的书面和日常含义，这有什么奇怪的吗？因此，当我们试图理解借记和贷记的概念时，回到最开始的地方可能是很有帮助…​…​但首先需要了解一些背景。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;点击 &lt;a href=&quot;https://youtu.be/2Vlsr7gP3M8&quot;&gt;Debits and Credits - Founding Principles&lt;/a&gt;观看视频。（自备梯子）&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;基本会计概念为会计学生而准备&quot;&gt;基本会计概念：为会计学生而准备&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这个培训课程针对有意愿学习更多会计知识的学生们。虽然是针对学生开发的课程，但是对其他有兴趣全面理解会计概念的人也是有帮助的。在开始本课程之前，建议先完成 &lt;a href=&quot;https://www.basicaccountingconcepts.education/basic-accounting-concepts-1-define-accounting/&quot;&gt;基本会计概念1：定义&lt;/a&gt;。本培训课程假定你对会计有一点了解，但又意识到要在工作应用或学习中跟进一步，你需要更全面地了解借记和贷记的概念。因此，本课程旨在从学生会计员的角度，提供&quot;借记&quot;和&quot;贷记&quot;概念的培训。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;关键词&quot;&gt;关键词&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;借记，贷记，公司，账户，会计概念，记账，交易，会计系统，Luca Pacioli，账户类型，复式记账，交易的两面性&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;学习成果&quot;&gt;学习成果&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;完成本次培训课程后，你将能够回答以下重点问题：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;借记和贷记的由来是什么？&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;为什么叫做借记和贷记？&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;借记和贷记的基本概念是什么？&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;14世纪的人们是如何应用借记和贷记的？&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;是否有应用借记与贷记的其他方法？&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;简介借记和贷记&quot;&gt;简介：借记和贷记&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;在字典中，记账系统中的&lt;strong&gt;借记&lt;/strong&gt;定义为&quot;记录在左边的交易记录&quot;，&lt;strong&gt;贷记&lt;/strong&gt;定义为&quot;记录在右边的交易记录&quot;。现在一些人对这样的定义也能接受，并且在学习了会计的其他所有的规则之后，成为了非常好的会计员。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2022/03/images/t-txn.png&quot; alt=&quot;T型账户&quot; width=&quot;600&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 1. T型账户
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;不过，还有另外一些人希望对借记和贷记这两个基本会计概念有更多的理解，以便更有意义的应用它们。如果你是后一种人的话，这个课程就非常适合你。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这个课程也将会说明&quot;规则必须要学习，但是到一定阶段后规则背后的原因也必须讲清楚；不然的话就没有太多教育价值&quot;。（Russel，B. （1924） Economic Individualism，Cambridge，On Education）。在课程继续往下之前，不论是规则学习者还是概念理解学习者都有必要记住下边表格中的内容和扎实理解在记账过程中不同账户类型的定义。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;exampleblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;div class=&quot;paragraph&quot;&gt; 
     &lt;p&gt;注：非常清楚的是会计中使用的术语&quot;借记&quot;和&quot;贷记&quot;有其特殊的含义，不应该和他们的其他意思混淆。（例如欠别人的钱的债务和可以延迟支付购买商品的信用就不是会计中借记和贷记的意思）。同时，在同一个国家，一个术语的会计含义和它的常规含义也有不一样的用法。&lt;/p&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2022/03/images/debits-and-credits.jpg&quot; alt=&quot;借记与贷记-缩略图&quot; width=&quot;600&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 2. 借记与贷记缩略图
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;admonitionblock note&quot;&gt; 
   &lt;table&gt; 
    &lt;tbody&gt;
     &lt;tr&gt; 
      &lt;td class=&quot;icon&quot;&gt; &lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt; &lt;/td&gt; 
      &lt;td class=&quot;content&quot;&gt; 点击 &lt;a href=&quot;https://app.box.com/s/v4j6okexia4y6lnj50t0&quot;&gt;https://app.box.com/s/v4j6okexia4y6lnj50t0&lt;/a&gt;下载原始文档 &lt;/td&gt; 
     &lt;/tr&gt; 
    &lt;/tbody&gt;
   &lt;/table&gt; 
  &lt;/div&gt; 
  &lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt; 
   &lt;caption class=&quot;title&quot;&gt;
    Table 1. 我要借记还是贷记？
   &lt;/caption&gt; 
   &lt;colgroup&gt; 
    &lt;col style=&quot;width: 33.3333%;&quot;&gt; 
    &lt;col style=&quot;width: 33.3333%;&quot;&gt; 
    &lt;col style=&quot;width: 33.3334%;&quot;&gt; 
   &lt;/colgroup&gt; 
   &lt;thead&gt; 
    &lt;tr&gt; 
     &lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;账户类型&lt;/th&gt; 
     &lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;账户增加时，记作：&lt;/th&gt; 
     &lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;账户减少时，记作：&lt;/th&gt; 
    &lt;/tr&gt; 
   &lt;/thead&gt; 
   &lt;tbody&gt; 
    &lt;tr&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;资产（Assets）&lt;/p&gt;&lt;/td&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;借记&lt;/p&gt;&lt;/td&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;贷记&lt;/p&gt;&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;负债（Liabilities）&lt;/p&gt;&lt;/td&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;贷记&lt;/p&gt;&lt;/td&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;借记&lt;/p&gt;&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;所有者权益（Owner’s Equity）&lt;/p&gt;&lt;/td&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;贷记&lt;/p&gt;&lt;/td&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;借记&lt;/p&gt;&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;收入（Revenue）&lt;/p&gt;&lt;/td&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;贷记&lt;/p&gt;&lt;/td&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;借记&lt;/p&gt;&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;支出（Expense）&lt;/p&gt;&lt;/td&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;借记&lt;/p&gt;&lt;/td&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;贷记&lt;/p&gt;&lt;/td&gt; 
    &lt;/tr&gt; 
   &lt;/tbody&gt; 
  &lt;/table&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2022/03/images/debit-or-credit.jpg&quot; alt=&quot;借记还是贷记缩略图&quot; height=&quot;400&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 3. 借记还是贷记缩略图
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;admonitionblock note&quot;&gt; 
   &lt;table&gt; 
    &lt;tbody&gt;
     &lt;tr&gt; 
      &lt;td class=&quot;icon&quot;&gt; &lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt; &lt;/td&gt; 
      &lt;td class=&quot;content&quot;&gt; 点击 &lt;a href=&quot;https://app.box.com/s/e5ls2e8h1g7h8ykxfp3p&quot;&gt;https://app.box.com/s/e5ls2e8h1g7h8ykxfp3p&lt;/a&gt;下载海报 &lt;/td&gt; 
     &lt;/tr&gt; 
    &lt;/tbody&gt;
   &lt;/table&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;在用表1中的方法，你记录公司账户交易的时候可能会有以下问题：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;交易相关的账户是什么？（至少涉及2个账户）&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;每个账户分别属于哪个账户分组？（必须属于五个分组之一）&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;该交易在账户中增加还是减少了相应的交易额？&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;应用表格中的逻辑。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;确保&quot;借记&quot;部分的总金额=&quot;贷记&quot;部分的总金额。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt; 
   &lt;caption class=&quot;title&quot;&gt;
    Table 2. 基本账户类型的定义
   &lt;/caption&gt; 
   &lt;colgroup&gt; 
    &lt;col style=&quot;width: 50%;&quot;&gt; 
    &lt;col style=&quot;width: 50%;&quot;&gt; 
   &lt;/colgroup&gt; 
   &lt;thead&gt; 
    &lt;tr&gt; 
     &lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;账户类型&lt;/th&gt; 
     &lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;外行人的定义&lt;/th&gt; 
    &lt;/tr&gt; 
   &lt;/thead&gt; 
   &lt;tbody&gt; 
    &lt;tr&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;资产（Asset）&lt;/p&gt;&lt;/td&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;公司具有合法控制权的有价物品&lt;/p&gt;&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;负债（Liability）&lt;/p&gt;&lt;/td&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;公司欠外部实体的钱（比如债权人或者贷款提供者）&lt;/p&gt;&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;所有者权益（Equity or Owners Equity）&lt;/p&gt;&lt;/td&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;公司欠内部实体的钱（比如投资人或者所有者）&lt;/p&gt;&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;收入（Income）&lt;/p&gt;&lt;/td&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;客户购买公司所提供的商品或服务所支付的钱&lt;/p&gt;&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;支出（Expense）&lt;/p&gt;&lt;/td&gt; 
     &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;公司为了挣钱而消耗的资产和物资。&lt;/p&gt;&lt;/td&gt; 
    &lt;/tr&gt; 
   &lt;/tbody&gt; 
  &lt;/table&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;谁的视角&quot;&gt;谁的视角？&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;一个困扰大多数新手会计的问题是&quot;贷记&quot;记录出现在他们自己的银行账单上。他们刚刚学到&quot;银行里的现金&quot;属于资产，根据表1的逻辑，当资产增加的时候记为&quot;借记&quot;。。。他们会问为什么我存钱的时候银行账户中的&quot;贷记&quot;总额反而增加了？&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;答案对会计系统来说非常基础，也就是&lt;strong&gt;每个公司都从自己的视角记录交易&lt;/strong&gt;。所以从银行的视角想一下。。。他们怎么看你刚刚存进去的钱？那是谁的钱？没错，肯定是你的钱。所以你的存款从银行的视角看就是负债（银行欠存款用户的钱）。当你存款到你的账户时，&lt;strong&gt;银行&lt;/strong&gt;的负债就增加了，这也是为什么银行把你的账户记录为&quot;贷记&quot;（根据表1的逻辑）。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;课程借记与贷记&quot;&gt;课程：借记与贷记&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;第1部分借记和贷记的由来是什么&quot;&gt;第1部分：借记和贷记的由来是什么？&lt;/h3&gt; 
   &lt;div class=&quot;paragraph right&quot;&gt; 
    &lt;p&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;https://www.reploop.org/blog/2022/03/images/illustrations.jpg&quot; alt=&quot;达芬奇的插画&quot; width=&quot;400&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;在更原始的贸易时代，记账并不是什么大问题，因为商品的生产或者制造者往往也是市场上销售或者交换该商品的人。然而，文艺复兴时期，由罗马建造的交通系统和更复杂社会比如意大利（尤其是威尼斯）的发展带来了贸易和银行系统的巨大增长。因此，14世纪的威尼斯商人开发了会计系统来精确记录这些当时流行的也更复杂的交易。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;现在，那个时代的修士和数学家Luca Pacioli（1446-1517）被广泛的认为是&quot;会计之父&quot;。因为他是第一个在他的名为&quot;数学，集合，比例以及比例关系的知识汇总&quot;（翻译书名）的书中编写并发表这个会计系统的。这本书出版于1494年（大约是哥伦布发现美洲的时期），并且它是古腾堡出版社最早出版的书籍之一。Luca没有说是自己发明的会计系统，不过他确实是用其他人更容易理解的方式把它书写出来了。他记录意大利文艺复兴时期威尼斯商人使用的会计系统的目的是帮助Urbino的公爵Guidobaldo管理自己的财务。这个仅用全书五部分之中的一部分来描述的系统后来被称为&quot;复式记账&quot;系统。书中关于会计系统的36个简短章节是随后上百年里唯一的教科书，其原则一直为会计师所遵循，直到今日。 有趣的是，Luca Pacioli实际上和达芬奇的是同事，而且是达芬奇帮助他绘制了他的第二本最重要的书（神圣比例）的手稿中的插画。本书作者提到了这一事实，达芬奇也在他的笔记中多次提到Luca Pacioli。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;上面是多面体的插画，也是达芬奇在Luca书中的插图之一。Marcino Guerrero在他的文章中披露了更多关于Luca和达芬奇的其他趣事。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;imageblock left&quot;&gt; 
    &lt;div class=&quot;content&quot;&gt; 
     &lt;img src=&quot;https://www.reploop.org/blog/2022/03/images/summa-2.jpg&quot; alt=&quot;基本会计概念&quot; width=&quot;180&quot;&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;Luca的大部分工作仍然支撑着我们现在所用的会计系统。来自他1494年出版的书中的那些基本会计概念至今还在沿用的有：&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;ulist&quot;&gt; 
    &lt;ul&gt; 
     &lt;li&gt; &lt;p&gt;会计周期&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;流水账和分类账的使用&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;借记总金额等于贷记总金额：复式记账&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;账户分为资产（包括应收账款和应付账款），负债，初始资金，收入和支出5类&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;年底结算&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;试算表，他相信可以用来说明分类帐目的结余的。&lt;/p&gt; &lt;/li&gt; 
    &lt;/ul&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;sect3&quot;&gt; 
    &lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt; 
    &lt;div class=&quot;paragraph&quot;&gt; 
     &lt;p&gt;在第1部分，我们了解了借记和贷记500年的历史，以及修士和数学家的Luca Pacioli通过他的复式记账系统为会计学做出的显著贡献。&lt;/p&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;第2部分为什么叫做借记和贷记&quot;&gt;第2部分：为什么叫做借记和贷记？&lt;/h3&gt; 
   &lt;div class=&quot;imageblock left&quot;&gt; 
    &lt;div class=&quot;content&quot;&gt; 
     &lt;img src=&quot;https://www.reploop.org/blog/2022/03/images/latin-coin.jpg&quot; alt=&quot;拉丁硬币&quot; width=&quot;180&quot;&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;我们要知道，Luca与其说是会计师，不如说是一名数学家，所以他的大脑会下意识的去寻找支撑威尼斯商人使用的财务记录系统的关键原则、概念和对称性（symmetry）。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;他识别出来的关键概念有（1）在会计领域内，企业（或公司）是一个有自己权利的、有别于其所有者的独立实体。另外一个是（2）财务系统是封闭的系统。也就是说钱不是凭空产生，一个人收到的钱一定是别人给的，反之亦然。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;这种给出和收到的封闭系统让他看到和公司有关的交易是涉及2方的概念。例如，当一个人委托一定数量的钱给一个独立的不同公司，那个公司就欠此人同样数目的钱并有偿还的义务。Luca用他的母语拉丁文将委托行为命名为&quot;Credre&quot;（意思是委托）以及公司相应的偿还义务命名为&quot;Debere&quot;（意思是欠钱）&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;因此，从公司的角度，他可以看出这个两面性原则对于该公司的每一笔交易都是成立的。对他来说，这不仅是一个公式，而是说交易的任何一方不能单独存在。在封闭系统中，每个&quot;Debere&quot;必须有一个对应的&quot;&quot;Credre&quot;，反之亦然。换句话说，&quot;Debere&quot;和&quot;Credre&quot;就是同一硬币的两面。（在金融领域，当某人&quot;委托&quot;钱财的时候一定有人会欠这部分钱）。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;Luca还注意到这种交易的两面性引申自经济资源的从一个地方转移到另一个的地方的事实。换句话说，对于每一笔交易，一定是经济资源从其来源转移到另一个目的地了。他再次应用了这一概念，即当经济资源从一个地方流向另一个地方时，来源记为贷记，目的地记为借记。他是如此确信两面性的概念，以至于他宣称任何人在没有确认&quot;借记&quot;总额和&quot;&quot;贷记&quot;总额相等之前不允许睡觉。（贷记=借记）&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;exampleblock&quot;&gt; 
    &lt;div class=&quot;content&quot;&gt; 
     &lt;div class=&quot;paragraph&quot;&gt; 
      &lt;p&gt;注：英语翻译者使用拉丁词根来翻译这些概念，因此将他们命名为借记和贷记。也非常有可能我们也从拉丁词根中得出了这两概念的缩写形式（Dr 和 Cr）。因为英文词借记中没有&quot;r&quot;，但在其拉丁文&quot;Debere&quot;中有一个。&lt;/p&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;sect3&quot;&gt; 
    &lt;h4 id=&quot;总结_2&quot;&gt;总结&lt;/h4&gt; 
    &lt;div class=&quot;paragraph&quot;&gt; 
     &lt;p&gt;在第2部分中，我们看到了两面性概念的出现，其中借记和贷记只是同一枚硬币的两面，就像中国的“阴阳”概念在一个更大的整体中是互补的对立面一样。我们开始看到支持借记和贷记应用的概念，以及与原始拉丁词根及其原始含义的联系。&lt;/p&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;第3部分借记和贷记的基本概念是什么&quot;&gt;第3部分：借记和贷记的基本概念是什么？&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;为了能够正确的理解借记与贷记，你需要首先了解支撑整个会计流程的概念。其中的一些称为会计惯例，而另一些则是加强了会计系统理解和记录交易的方式。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;sect3&quot;&gt; 
    &lt;h4 id=&quot;基本会计概念1_企业或公司是一个实体&quot;&gt;基本会计概念1： 企业或公司是一个实体&lt;/h4&gt; 
    &lt;div class=&quot;paragraph&quot;&gt; 
     &lt;p&gt;简单来说，法律系统把实体定义为能够根据本国法律起诉或者被起诉的自然人或者非自然人。世界上的大多数国家，公司是作为非自然人实体，并被赋予和自然人相同的权利和义务。会计学进一步扩展了这个概念，每一个公司（包括个体户和合伙企业）都有自己的&quot;会计实体&quot;，并且每个实体的收入与资产净值都是通过自己的交易计算的。&lt;/p&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;sect3&quot;&gt; 
    &lt;h4 id=&quot;基本会计概念2企业公司是有别于企业主的一个独立实体&quot;&gt;基本会计概念2：企业（公司）是有别于企业主的一个独立实体&lt;/h4&gt; 
    &lt;div class=&quot;paragraph&quot;&gt; 
     &lt;p&gt;尽管一个公司可以&quot;合法&quot;的支配一些有价资产，但是它不是这些东西的最终拥有者。换句话说，如果公司出售所有能卖的东西，它有义务用出售所得的钱去偿还其他人或者实体提出的索赔要求。公司首先要偿还的是外部人员的索赔（例如贷款和债权），然后用余下的钱去偿还所有者的索赔。企业然后回到了刚开始的状态，没有任何偿还义务也不支配任何有价资产。&lt;/p&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;sect3&quot;&gt; 
    &lt;h4 id=&quot;基本会计概念3_人可以有多种身份&quot;&gt;基本会计概念3： 人可以有多种身份&lt;/h4&gt; 
    &lt;div class=&quot;paragraph&quot;&gt; 
     &lt;p&gt;虽然这并不是一个严格的会计概念，但却是识别交易记录的正确视角时非常重要的一个概念。就像一个人可以是父母，兄弟，表兄弟或者子孙，一个人也可以是一家公司的投资人，一家公司的债权人/债务人，一家公司的经理或者控制一家公司运营的董事。最重要的是，会计中总是从公司的视角来分析和记录的交易，而记录人是经理的身份（不是所有者）。&lt;/p&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;sect3&quot;&gt; 
    &lt;h4 id=&quot;基本会计概念4_每笔交易都涉及2方一是经济资源的来源一是经济资源的去向&quot;&gt;基本会计概念4： 每笔交易都涉及2方，一是经济资源的来源，一是经济资源的去向&lt;/h4&gt; 
    &lt;div class=&quot;paragraph&quot;&gt; 
     &lt;p&gt;财务世界是一个封闭的系统。也就是说钱不会凭空产生也不会凭空消失。如果一个人或者实体收到了钱，那一定从另一个人或实体来的。任何涉及经济资源的交易都必须有一个来源和一个去向。这是我们第一次了解今天在会计中使用的&quot;借记&quot;和&quot;贷记&quot;系统。&lt;/p&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;sect3&quot;&gt; 
    &lt;h4 id=&quot;基本会计概念5_企业公司的经营所得归企业主&quot;&gt;基本会计概念5： 企业（公司）的经营所得归企业主。&lt;/h4&gt; 
    &lt;div class=&quot;paragraph&quot;&gt; 
     &lt;p&gt;正如基本会计概念2所说的那样，从会计的视角看公司实际上不是任何东西的所有者。它可能具有合法的&quot;所有权&quot;或者控制权，当从根本上讲它是所有者为管理其事务而设立的会计实体。因此，当一家公司盈利时，它是所有者的利益而不是公司的。记住，如果把公司能卖的全部卖了，售卖所得首先用来偿还债务，余下的都归公司的所有者，公司什么也没剩下。&lt;/p&gt; 
    &lt;/div&gt; 
    &lt;div class=&quot;imageblock text-center&quot;&gt; 
     &lt;div class=&quot;content&quot;&gt; 
      &lt;img src=&quot;https://www.reploop.org/blog/2022/03/images/words-accounting.jpg&quot; alt=&quot;词云&quot; width=&quot;50%&quot;&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;sect3&quot;&gt; 
    &lt;h4 id=&quot;总结_3&quot;&gt;总结&lt;/h4&gt; 
    &lt;div class=&quot;paragraph&quot;&gt; 
     &lt;p&gt;在第三部分，我们理解了几个会计基本概念，这些概念不仅仅是&quot;借记&quot;与&quot;贷记&quot;的基础，同时也是整个会计系统的基础。我们了解了：&lt;/p&gt; 
    &lt;/div&gt; 
    &lt;div class=&quot;ulist&quot;&gt; 
     &lt;ul&gt; 
      &lt;li&gt; &lt;p&gt;企业或者公司是一个实体&lt;/p&gt; &lt;/li&gt; 
      &lt;li&gt; &lt;p&gt;企业（公司）是有别于企业主的一个独立实体&lt;/p&gt; &lt;/li&gt; 
      &lt;li&gt; &lt;p&gt;人可以有多种身份且可以用不同的身份工作&lt;/p&gt; &lt;/li&gt; 
      &lt;li&gt; &lt;p&gt;每个金融交易都涉及2方（一个来源一个去向）&lt;/p&gt; &lt;/li&gt; 
      &lt;li&gt; &lt;p&gt;公司经营所得利润归公司的所有者&lt;/p&gt; &lt;/li&gt; 
     &lt;/ul&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;第4部分14世纪的人们是如何应用借记和贷记的&quot;&gt;第4部分：14世纪的人们是如何应用借记和贷记的？&lt;/h3&gt; 
   &lt;div class=&quot;imageblock text-center&quot;&gt; 
    &lt;div class=&quot;content&quot;&gt; 
     &lt;img src=&quot;https://www.reploop.org/blog/2022/03/images/venice.jpg&quot; alt=&quot;威尼斯&quot; width=&quot;60%&quot;&gt; 
    &lt;/div&gt; 
    &lt;div class=&quot;title&quot;&gt;
     Figure 4. 威尼斯
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;正如Luca所说的，他所记录的会计系统被威尼斯商人广泛使用。这些人似乎是15世纪的企业家。我们假设一名叫做安东尼奥的威尼斯企业家，在Luca1494年完成他著名的书之前，请Luca为他的新企业（公司）记录财务账目。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;exampleblock&quot;&gt; 
    &lt;div class=&quot;content&quot;&gt; 
     &lt;div class=&quot;paragraph&quot;&gt; 
      &lt;p&gt;注：为了故事方便，我们使用美元和英语会计术语&lt;/p&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;故事开始…​…​&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;安东尼奥发现了一个贩卖意大利橄榄到埃及的机会，并且觉得能大发一笔。因此，安东尼奥（作为新公司的总经理）接触了一个意大利橄榄供应商，说服他提供价值100000美元的橄榄，并且等到他从埃及回来的时候再付款。安东尼奥没有提起他将要赚到的钱，因为橄榄供应商只关心卖橄榄出去。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;这样，Luca有了第一笔交易，用借记和贷记的拉丁原意记录如下：&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;ulist&quot;&gt; 
    &lt;ul&gt; 
     &lt;li&gt; &lt;p&gt;经济资源的&lt;strong&gt;来源&lt;/strong&gt;是意大利橄榄供应商，公司现在欠他100000美元：记为贷记（Cr）应付账款。&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;经济资源转移的&lt;strong&gt;去向&lt;/strong&gt;是公司收到的橄榄的库存：记为借记（Dr）库存&lt;/p&gt; &lt;/li&gt; 
    &lt;/ul&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;利用表1中的方法，我们做如下记录：&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;listingblock&quot;&gt; 
    &lt;div class=&quot;content&quot;&gt; 
     &lt;pre&gt;资产：库存（增加）               $100,000 Dr
负债：应付账款给橄榄供应商（增加）  $100,000 Cr&lt;/pre&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;很快，安东尼奥就带他去看他刚花50000美元买的船。其中的30000是安东尼奥自己的钱，另外20000从银行贷款。安东尼奥非常兴奋，因为他终于有办法把想法变为现实并且通过贩卖橄榄来赚取他梦寐以求的财富。&lt;strong&gt;Luca意识到当安东尼奥不停的说他做了什么的时候，其实是说他作为总经理的公司做了什么。&lt;/strong&gt;Luca知道公司已经产生了第二笔交易，再次从公司的视角记录如下：&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;ulist&quot;&gt; 
    &lt;ul&gt; 
     &lt;li&gt; &lt;p&gt;一个经济资源的&lt;strong&gt;来源&lt;/strong&gt;是银行，公司从银行贷款20000美元：贷记（CR）银行贷款&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;另一个经济资源的&lt;strong&gt;来源&lt;/strong&gt;是公司的所有者安东尼奥自己出的30000美元。公司将他看作一个独立的实体：贷记（Cr）初始资金&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;经济资源的&lt;strong&gt;去向&lt;/strong&gt;是从银行和所有者那筹来的总计50000美元购买的船：借记（Dr）船&lt;/p&gt; &lt;/li&gt; 
    &lt;/ul&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;应用表1的方案，我们做如下记录：&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;listingblock&quot;&gt; 
    &lt;div class=&quot;content&quot;&gt; 
     &lt;pre&gt;资产：船（增加）                    $50,000 Dr
负债：银行贷款（增加）               $20,000 Cr
所有者权益：初始资金（增加）          $30,000 Cr&lt;/pre&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;Luca很高兴，因为这2次交易中（1）总的贷记金额等于总的借记金额并且（2）遵循了&quot;复式记账&quot;系统的基本概念。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;sect3&quot;&gt; 
    &lt;h4 id=&quot;总结_4&quot;&gt;总结&lt;/h4&gt; 
    &lt;div class=&quot;paragraph&quot;&gt; 
     &lt;p&gt;借助支撑&quot;复式记账&quot;系统的概念以及经济资源的来源和去向的概念，我们尝试去了解Luca在记录这个虚构的15世纪企业的账本条目时的思考。&lt;/p&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;第5部分是否有应用借记与贷记的其他方法&quot;&gt;第5部分：是否有应用借记与贷记的其他方法？&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;今天我们看Luca的笔记并且从中发现了一个新的模式。显然Luca能用经济资源的来源和去向的概念记录所有的交易。 看起来就是…​…​&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;imageblock&quot;&gt; 
    &lt;div class=&quot;content&quot;&gt; 
     &lt;img src=&quot;https://www.reploop.org/blog/2022/03/images/source-and-destination-of-value.jpg&quot; alt=&quot;资金的来源和去向总额相等&quot; width=&quot;50%&quot;&gt; 
    &lt;/div&gt; 
    &lt;div class=&quot;title&quot;&gt;
     Figure 5. 资金的来源和去向总额相等
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;…​…​先继续讲故事。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;成功完成他的&quot;销售之旅&quot;后，安东尼奥很快回到了城里。安东尼奥说他（作为经理）以200000美元卖掉了所有的橄榄，这趟旅程仅花费了30000美元，其中还包括了付给银行的1000美元利息。他说他用销售收入付了这些费用，他还把欠橄榄供应商的钱还了。他还说他为了庆祝这次成功的销售之旅，用1000美元的销售收入给家里买了家具。我们马上意识到公司的第3次交易产生了，涉及4个主要部分：&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;ulist&quot;&gt; 
    &lt;ul&gt; 
     &lt;li&gt; &lt;p&gt;第1部分：销售橄榄所得的200000美元现金&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;第2部分：支付橄榄供应商的未结账款&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;第3部分：用30000美元销售收入来支付旅途费用和银行利息&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;第4部分：安东尼奥（作为企业主）支取并使用了10000美元&lt;/p&gt; &lt;/li&gt; 
    &lt;/ul&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;接下来我们代替Luca记录这些交易，用经济资源的来源和去向的方法决定交易是&quot;借记&quot;还是&quot;贷记&quot;，并将其结果与根据上面表1中所列规则得出的结果进行比较。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;下面是我们得出的结果：&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt; 
    &lt;caption class=&quot;title&quot;&gt;
     Table 3. 交易记录
    &lt;/caption&gt; 
    &lt;colgroup&gt; 
     &lt;col style=&quot;width: 20%;&quot;&gt; 
     &lt;col style=&quot;width: 20%;&quot;&gt; 
     &lt;col style=&quot;width: 20%;&quot;&gt; 
     &lt;col style=&quot;width: 20%;&quot;&gt; 
     &lt;col style=&quot;width: 20%;&quot;&gt; 
    &lt;/colgroup&gt; 
    &lt;thead&gt; 
     &lt;tr&gt; 
      &lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;公司的动作&lt;/th&gt; 
      &lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;来源还是去向？&lt;/th&gt; 
      &lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;贷记/借记&lt;/th&gt; 
      &lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;交易额&lt;/th&gt; 
      &lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;账户类型&lt;/th&gt; 
     &lt;/tr&gt; 
    &lt;/thead&gt; 
    &lt;tbody&gt; 
     &lt;tr&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot; colspan=&quot;5&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;交易第1部分&lt;/p&gt;&lt;/td&gt; 
     &lt;/tr&gt; 
     &lt;tr&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;公司卖了价值200000美元的商品&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;这笔进入公司的资金&lt;strong&gt;来源&lt;/strong&gt;是销售橄榄给消费者所得收入&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;贷记&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;200000&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;收入（收入-增加）= 贷记&lt;/p&gt;&lt;/td&gt; 
     &lt;/tr&gt; 
     &lt;tr&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;公司收到销售橄榄所得的200000美元现金&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;销售收入的&lt;strong&gt;去向&lt;/strong&gt;是现金资产&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;借记&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;200000&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;资产（资产-增加）=借记&lt;/p&gt;&lt;/td&gt; 
     &lt;/tr&gt; 
     &lt;tr&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot; colspan=&quot;5&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;交易第2部分&lt;/p&gt;&lt;/td&gt; 
     &lt;/tr&gt; 
     &lt;tr&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;公司用销售收入支付橄榄供应商&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;用于支付供应商的资金&lt;strong&gt;来源&lt;/strong&gt;是现金资产&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;贷记&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;100000&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;资产（资产-减少）=贷记&lt;/p&gt;&lt;/td&gt; 
     &lt;/tr&gt; 
     &lt;tr&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;公司支付了橄榄供应商的未结清账款&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;资金的&lt;strong&gt;去向&lt;/strong&gt;是欠供应商的债务&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;借记&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;100000&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;负债（负债-减少）=借记&lt;/p&gt;&lt;/td&gt; 
     &lt;/tr&gt; 
     &lt;tr&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot; colspan=&quot;5&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;交易第3部分&lt;/p&gt;&lt;/td&gt; 
     &lt;/tr&gt; 
     &lt;tr&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;公司用销售收入支付旅途费用和银行利息&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;资金&lt;strong&gt;来源&lt;/strong&gt;是现金资产&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;贷记&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;30000&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;资产（资产-减少）=贷记&lt;/p&gt;&lt;/td&gt; 
     &lt;/tr&gt; 
     &lt;tr&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;公司支付银行利息&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;资金的一部分&lt;strong&gt;去向&lt;/strong&gt;是银行利息&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;借记&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1000&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;支出（支出-增加）=借记&lt;/p&gt;&lt;/td&gt; 
     &lt;/tr&gt; 
     &lt;tr&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;公司支付旅途费用&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;资金的另一部分&lt;strong&gt;去向&lt;/strong&gt;是旅途费用&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;借记&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;29000&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;支出（支出-增加）=借记&lt;/p&gt;&lt;/td&gt; 
     &lt;/tr&gt; 
     &lt;tr&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot; colspan=&quot;5&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;交易第4部分&lt;/p&gt;&lt;/td&gt; 
     &lt;/tr&gt; 
     &lt;tr&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;公司提取10000美元现金&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;资金的&lt;strong&gt;来源&lt;/strong&gt;是现金资产&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;贷记&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;10000&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;资产（资产-减少）=贷记&lt;/p&gt;&lt;/td&gt; 
     &lt;/tr&gt; 
     &lt;tr&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;安东尼奥（作为企业主）个人使用了公司的这部分钱&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;资金的&lt;strong&gt;去向&lt;/strong&gt;是企业主&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;借记&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;10000&lt;/p&gt;&lt;/td&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;权益（权益-减少）=借记&lt;/p&gt;&lt;/td&gt; 
     &lt;/tr&gt; 
     &lt;tr&gt; 
      &lt;td class=&quot;tableblock halign-left valign-top&quot; colspan=&quot;5&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;交易记录结束&lt;/p&gt;&lt;/td&gt; 
     &lt;/tr&gt; 
    &lt;/tbody&gt; 
   &lt;/table&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;所有的账户类型都涉及到了，并且我们用&quot;来源与去向&quot;的方法得出了与用表1的方法一样的结果，除此之外，这样还有实际意义，而且它们与Luca的原始拉丁含义是保持一致的。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;sect3&quot;&gt; 
    &lt;h4 id=&quot;总结_5&quot;&gt;总结&lt;/h4&gt; 
    &lt;div class=&quot;paragraph&quot;&gt; 
     &lt;p&gt;在第5部分，我们探索了通过经济资源的来源和去向的角度解释所有交易的想法。仅用2个主要的问题，我们就能够应用一个不同的而且更有实际意义的方法来确定公司账本中的一笔交易是借记还是贷记。我们试图将这种方法与Luca Pacioli对借记和贷记术语的可能含义联系起来。因此，除了学习表1的方法并将其中的逻辑应用于你的借记于贷记之外，你还可以应用从Luca的工作的第一原则发展而来的另一种方法，即任何交易中转移的经济资源的来源记为贷记，其相应的去向记为借记。&lt;/p&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;补充资源&quot;&gt;补充资源&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;&quot;Tao of Financial Information&quot;的第21章，http://taofinancial.blogspot.com/&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;关于记账和会计的文章&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;结论借记与贷记&quot;&gt;结论：借记与贷记&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;本次培训课程的主要收获是：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;理解借记和贷记术语的由来&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;理解他们叫做借记和贷记的原因&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;识别和理解借记与贷记中的基本会计概念&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;了解14世纪时人们是如何应用借记与贷记的&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;找到另外一种在交易中应用借记和贷记的有意义的方法&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;我们在本文开始的时候就着手全面理解关于借记和贷记的基本会计概念。我们知道我们可以通过简单的应用表1中的方法就可以成为一个成功的会计员，但是有些人想要理解&quot;为什么&quot;是这样。通过回到他们产生的时间，查看其本来的意思，我们能够应用一个新的方法决定交易中借记和贷记。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;本文译自https://www.basicaccountingconcepts.education/basic-accounting-concepts-2-debits-and-credits, 拷贝地址到浏览器或者&lt;strong&gt;&lt;a href=&quot;https://www.basicaccountingconcepts.education/basic-accounting-concepts-2-debits-and-credits/&quot;&gt;点此&lt;/a&gt;&lt;/strong&gt;阅读原文。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>这些年学过/用过的编程语言</title>
                <link>https://www.reploop.org/blog/2021/11/languages-i-learned-those-years.html</link>
                <pubDate>Fri, 19 Nov 2021 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2021/11/languages-i-learned-those-years.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;计算机专业科班，工作10+年，一直没有停止过编程。从事的工作兜兜转转，刚好就碰到了好多编程语言，下面说说我和这些编程语言的缘分。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;缘分&quot;&gt;缘分&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;java&quot;&gt;Java&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;Java是工作之前做的项目用的语言，学习和实践都需要用到的。他也是我工作之后的主要语言。第一份工作去了搜狐，当时的面试官后来评价说当时的面试表现比有些毕业几年的人都好。（不是自吹，可能刚好蒙对了命题范围，我当然也有百度笔试不过的经历）。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;Java是我唯一不停的跟踪其发展，尝试新功能，保持刻意学习的语言。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;lua&quot;&gt;Lua&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;Lua就比较巧儿，决定用之前还没写过一行Lua代码。当时面临的场景是有个业务涉及到一些规则频繁的变动，实现的时候是用后端Java服务来做的，所以更新就会稍微麻烦一点。当时使用的反向代理是nginx，一直想说写个nginx插件把这个事情做了。这样规则计算和流量型的nginx集合起来，还能提高机器资源利用率。后来就发现了Lua和nginx结合比较开发友好，比C语言省事多了。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;想清楚之后就可以学习Lua，真的是从Reading The Fucking Manual开始的，然后看了几本电子书，边看边写的。最后写出来的是一个Lua+MongoDB操作的规则计算引擎，每天服务1+亿人。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;只可惜，后来想想这种越是灵活的东西，越是对用户不友好，学习成本高，面向一般人员的UI不好做，只能给程序员使用了。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;javascript&quot;&gt;Javascript&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;Javascript我想Web开发的人很早的时候就接触了。 说几个古老的技术大概就理解了：ASP，JSP，jQuery，Ajax等。直到后来前后端分离之后，Javascript已然是最火热的语言之一了。大体上就是这些年后端造的轮子都会用Javascript再造一遍的意思。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;ruby&quot;&gt;Ruby&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;Ruby是被迫学习的。面临的情况是团队不得已要优化，结果就是人走了，项目还得运行迭代。 刚开始看着源代码头大，然后就是看官网的语言设计原则，找了4，5本书快速看一遍，逐渐适应了另一种风格的语言，然后就逐渐的看明白了并且开始写bug了。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;一段时间被Ruby惊艳到了，觉得Ruby大概是CRUD工程师很好的选择，对于创业公司来讲，撸一个MVP是分分钟的事情。只可惜人才供给少，一般公司不敢入Ruby的坑吧。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;golang&quot;&gt;Golang&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;Golang是公司买了一个系统，这个系统就是Golang写的。我要负责接收这个系统。听说过『Google出品，必属精品』的话，那就能想到Golang的新闻或者文章很多，还有很多拿他和Java做对比。这个项目不仅仅是一个业务系统，还涉及到算法。就这样我就开始从听过过Golang的人，到开始维护Golang版本的维特比，DFS与剪枝等算法。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;clojure&quot;&gt;Clojure&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;Clojure语言是用Storm流式计算系统的时候碰到的。当时Storm非常热门，但是其核心代码是用Clojure写的。有些行为不理解的时候，最真实的答案就再源代码里面。所以就必须去理解，去调试，去验证。Clojure只能是远观，因为没有写部署到生产环境的Clojure代码。写Clojure代码，大概有一种手动构建抽象语法树的意思(AST)。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;scala&quot;&gt;Scala&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;JVM生态中的函数式编程，出来的很早，加上当时Twitter公司的很多开源项目就用Scala写的，当时所在的公司里面也有项目在用。也仅仅是浏览过几本书。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;shell&quot;&gt;Shell&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;工作大部分时间都是面向服务端的而且需要自己运维机器，所有命令行工具就必须要掌握。所以统计脚本，写过服务启动、停止的脚本，写过监控的脚本。有很多问题用脚本验证一下也很快。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;swiftobject_c&quot;&gt;Swift/Object-C&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;也是团队优化项目不优化的情况下，开始维护iOS的APP。维护的过程中做一些必要的学习。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;kotlin&quot;&gt;Kotlin&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;机缘巧合，不得不开始写Android的APP了。刚开始用Java，团队里面的主力Android开发，也是一个好学的人。把Java代码逐步的都翻译为Kotlin了，也就依葫芦画瓢的开始学习Kotlin了。Java和Kotlin是两种思路，时不时的交错，写出来的代码两边都不像。就这样也算是半个主力，短时间内撸出来一个APP。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;c&quot;&gt;C&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;C语言除了学校里学过之后，工作中基本上和C打交道都是因为nginx。曾经和同事一起调试一个二分算法边界处理不严谨带来的偶发(数据相关)死循环的问题，连续debug了nginx好几天。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;python&quot;&gt;Python&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;Python大部分情况下是shell脚本搞不定了，就用Python来写写。谈不上会写Python，也没有经历过大型生产环境的项目。只能是放本字典再身边，用的时候翻字典，开卷考试那种。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;如何学习&quot;&gt;如何学习&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;从语言到工程应用，学习的过程基本上就是围绕着系统的生命周期来。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;dlist&quot;&gt; 
   &lt;dl&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     语言与代码 
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;见过的编程语言多了之后，学习的过程大概就不会重点放在语法的部分，而是着重要了解语言的设计思路，语言的特性。把这个理解透彻了，后面会事半功倍的。一上来就着急开始写代码，不停的遇到拦路虎，这时候就不停的搜索以解决问题。这就变成了所谓的『面向搜索引擎』的编程。等你静下心来回头看，每个问题的解决办法都透露着语言的哲学。 这个阶段我一般是找3+本书，都快速浏览一遍，然后把符合自己胃口的书再精读一下。对于有经验的程序员，我是相信『21天学会编程』的。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     模块化 
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;大点的项目都是多人协作共同开发，然后代码的组织方式就很重要。有时候觉得语言很简单，但是项目代码确很庞大。所以要对语言写成的文件，命名空间，类/函数，代码块，作用域等特别关注一下，这些东西是模块化中最基本的东西。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     中间件 
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;每个语言大概都有几个应用广泛的中间件，比如Java的Spring, Ruby的Rails等等。这也是要重点关注的地方，大部分项目都离不开这些中间件。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     数据库 
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;计算机程序是算法+数据组成的，也就是code+data。只要涉及数据，大概率是要用到数据库。语言生态对数据库的支持也很重要。Ruby生态的ActiveRecord所应用的Association Model对简单应用开发效率是非常大的提升。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     依赖管理 
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;大项目都需要有依赖管理，工具就要有个必要的了解。尤其是碰到依赖冲突，多版本，找不到的资源的情况下。 开源的语境下，这也是想快速应用开源的代码要掌握的工具。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     构建工具 
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;构建工具大部分开发者不需要关注，把源代码打包成可以在服务器或者应用容器内跑起来的程序，每个语言都提供对应的编译器。这里想强调的是持续构建，就是程序员只需要提交代码，后面的构建都不需要太多参与，解放程序员。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     部署工具 
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;把打包好的程序放到服务器上并且跑起来，这是部署工具要解决的问题。这部分可以是『人工智能』的手动用scp，ftp之类的工具放上去或者下载下来，然后用命令行来启动，小小作坊大概就是这样的了。再面对的机器数，应用数，应用类型，运维不同的情况下需要一个稳定的可扩展的工具帮助团队做部署。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     运维 
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;这部分设计监控，报警，修复，扩容，缩容，测试，性能，安全等等方面的东西。 程序是跑到计算机中的，所以对他赖以生存的环境是非常有必要了解的。也就是对操作系统，网络，数据库原理，安全加密，协议，标准，内存，CPU，磁盘等等方面都要有一定的了解，学无止境。&lt;/p&gt; 
    &lt;/dd&gt; 
   &lt;/dl&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;常有争论，谁是世界上最好的编程语言？我的答案是没有最好，只有最适合。也就是那句话：抛开场景谈功能都是耍流氓。每个语言都有其最佳应用场景，单纯的对比语言，首先就是评判标准都不统一，不一致，得出的结论也就没啥实际意义。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;还有一类问题，是我要不要学习某某语言？反过来看这可能不是你决定的，是事情决定的。当然你要是对某某语言特别有兴趣，那就自己学就好了。如果语言只是吃饭讨生活的工具，那就遇到什么样子的问题，准备最合适解决该问题的工具吧。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;最后，也经常听到有人接我不会某某语言，解决不了某某问题。 这就是问题还不够要命，职责还不够明确。职场上要不想办法解决了，要不就换一个坑位吧。作为程序员，以我不会某某语言为由，在我看来大概也不可能是一个优秀的工程师了，持续学习很重要。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>服务拓扑</title>
                <link>https://www.reploop.org/blog/2021/10/service-topology.html</link>
                <pubDate>Sat, 16 Oct 2021 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2021/10/service-topology.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;使用服务器部署服务的时候，各个服务之间的依赖关系通常是需要额外的工作来维护的。比如有一个MySQL数据库，在典型的运维场景，你想知道哪些应用依赖他就比较费劲，尤其是在一个变换频繁的团队中是需要一个统筹来管理的。 开源项目 &lt;a href=&quot;https://github.com/reploop/reploop-topology&quot;&gt;reploop-topology&lt;/a&gt;的目的就是快速发现服务拓扑，其基本假设是一台机器提供服务必须要监听服务端口，并且建立网络连接。这是典型的分布式场景下通过网络连接起来的多机器之间的交互方式。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;拓扑&quot;&gt;拓扑&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;主要利用 &lt;code&gt;lsof&lt;/code&gt; 与 &lt;code&gt;ps&lt;/code&gt; 命令获取主机上的监听的端口与服务进程。 需要在目标机器上执行如下命令：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;listingblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell script&quot; data-lang=&quot;shell script&quot;&gt;sudo lsof -i 4 -nPR;
sudo ps -ef;&lt;/code&gt;&lt;/pre&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;&lt;code&gt;lsof&lt;/code&gt; 命令获取机器上的所有网络连接，其中也包括了本地监听的端口信息，同时利用 &lt;code&gt;ps&lt;/code&gt; 取得机器上的所有的服务进程。接着通过 &lt;code&gt;lsof&lt;/code&gt; 和 &lt;code&gt;ps&lt;/code&gt; 的输出结果中的相同的 &lt;strong&gt;pid&lt;/strong&gt; 可以将网络连接归属到同一个服务进程，并且发现了进程之间的依赖关系。 接着将服务进程通过启动命令归属到同一个应用服务，这样就通过网络连接建立起此连接两端对应的服务之间的连接关系。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;一个网络连接，我们经常用5元组来唯一表示: (Source IP, Source Port, Destination IP, Destination Port, Protocol)。这就是源地址IP:Port，目的地址IP:Port ，以及相应的网络协议。下面就开始从基础的名词开始构建服务拓扑。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;名词&quot;&gt;名词&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;dlist&quot;&gt; 
   &lt;dl&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     IP
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;IP地址，每个网卡(NIC)有一个IP地址，并且在其子网内是唯一的。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     Port
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;网络端口，对于TCP协议，每个机器上是唯一的，同一时间不能被多个应用复用。有些端口是临时端口，可也就是只会出现一次的那种，处理的时候要注意。根据协议不同，有可能是TCP或者UDP协议。 TCP和UDP可以公用同一个端口，比如DNS服务可以同时绑定tcp/53和udp/53端口。 对于UDP的来说，一个端口可以同时被多个不同的应用绑定。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     Process
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;服务进程, 通过服务主入口区分不同的进程。也就是启动命令与main函数的命名空间。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     Server
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;机器，物理上的一台机器或者虚拟机。每台机器可以有多个网卡(NIC)，也就是多个IP。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     Server Port
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;服务器端口，一个服务的基本服务形式，一个服务上监听一个服务端口。 这里用(服务器:端口)取代通常理解的(IP:PORT)的形式，来处理一台机器上多网卡的情况。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     Service
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;应用服务，应用层面的服务，不考虑部署结构的应用服务。 这里需要注意的是一个服务可以仅仅作为请求的发起方(client模式)，从而不监听任何服务器端口。&lt;/p&gt; 
    &lt;/dd&gt; 
   &lt;/dl&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;div class=&quot;title&quot;&gt;
    ER图
   &lt;/div&gt; 
   &lt;p&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;https://www.reploop.org/blog/2021/10/images/relation.svg&quot; alt=&quot;ER图&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;通过lsof输出的网络连接IP:PORT→IP:PORT最终建立起Service之前的拓扑关系。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;div class=&quot;title&quot;&gt;
    服务拓扑
   &lt;/div&gt; 
   &lt;p&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;https://www.reploop.org/blog/2021/10/images/service.svg&quot; alt=&quot;服务拓扑&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这里也可以看出，通常一个服务既可以作为客户端依赖其他服务，也可以作为服务器提供服务。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;ip地址处理&quot;&gt;IP地址处理&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;在一个服务器上监听一个端口，通常有几种写法：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;*:Port, 监听所有网卡端口，也就是机器上的所有IP都可以访问这个端口。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;0.0.0.0:Port, 监听IPv4的端口，&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;以及本地回环地址127.0.0.1。 这些地址都将会处理为具体的IP地址。 具体是首先会通过 &lt;code&gt;lsof&lt;/code&gt; 的输出结果中汇总出有连接建立的所有本地IP地址，然后用这些IP地址来替换上面出现的特殊形式的IP地址。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;process关系&quot;&gt;Process关系&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;Linux服务器上的每个Process都有两个id，分别是PID与PPID。同一时刻服务器上的所有PID是不重复的，但是已经消亡的进程PID后面是可以重复被利用的。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;Linux下进程之间是一个树的关系，一个进程通过PPID指向其父进程。这点在处理 &lt;code&gt;lsof&lt;/code&gt; 的输出时很重要，因为一个进程本身可以监听端口，也可以让子进程去监听端口提供服务。比如一些守护进程做的事就是其他真正的服务子进程去服务，自己则是一直监控着子进程的健康状态。 但是所有的子进程都应该看作一个服务进程来处理。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;缺点&quot;&gt;缺点&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;dlist&quot;&gt; 
   &lt;dl&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     短连接场景 
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;lsof运行的时机很重要，可能采集不到或者不全。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     定时任务 
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;同样也是lsof的运行时机很重要，可能采集不到或者不全。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     外部服务 
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;第三方服务识别需要提前标注。此部分针对的是机器不能登陆的情况下，获取不到具体信息的情况，都归类为外部第三方服务。 如果有用到Aliyun的话，可以结合Aliyun的Open API，识别出阿里云上的SLB，数据库等资源，使得整个拓扑更清晰。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     多进程与进程管理 
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;通过Linux系统进程管理与监控工具启动的服务，真正服务的是子进程，这个影响服务的识别。&lt;/p&gt; 
    &lt;/dd&gt; 
   &lt;/dl&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;应用场景&quot;&gt;应用场景&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;以下是一些典型的应用场景：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;dlist&quot;&gt; 
   &lt;dl&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     发现空闲机器
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;机器上没有服务进程的话，可以认为机器是空闲的。或者可以辅以其他信息识别空闲机器。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     理解服务拓扑
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;理解服务之间的调用依赖关系。在抄抄代码的开发模式下，可能会无意引入不必要的服务。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     识别意外服务
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;一般应用服务非常好理解，但是这些服务所依赖的辅助服务，经常被忽略。比如读写文件系统，日志监控服务等。&lt;/p&gt; 
    &lt;/dd&gt; 
   &lt;/dl&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;在微服务体系下，调用链是必备的。通过他也是可以画出服务拓扑关系的。也就不需要这么麻烦了。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;The SO_REUSEPORT socket option, &lt;a href=&quot;https://lwn.net/Articles/542629/&quot; class=&quot;bare&quot;&gt;https://lwn.net/Articles/542629/&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;reploop-topology, &lt;a href=&quot;https://github.com/reploop/reploop-topology&quot; class=&quot;bare&quot;&gt;https://github.com/reploop/reploop-topology&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>Maven依赖管理理解</title>
                <link>https://www.reploop.org/blog/2021/09/maven-deps.html</link>
                <pubDate>Fri, 24 Sep 2021 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2021/09/maven-deps.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;根据 &lt;a href=&quot;https://www.jrebel.com/resources/java-developer-productivity-report-2021&quot;&gt;JRebel 2021 Java Developer Productivity Report&lt;/a&gt; ，Java项目构建工具中第一名的Maven占了67%，第二名的Gradle是20%。所以理解和掌握Maven是非常必要的。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;现在稍微大一点的Java项目都会涉及到bom和module，然后经过在pom.xml中的parent和dependency节点的组合之后，很方便的管理了。 不过也很容易造成模块或者依赖类库版本的冲突。而且这种问题一般编译期间不容易发现，到了运行期间就会出这种依赖的问题。遇到依赖的类库不符合预期的时候，我们一般就会问2个问题：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;怎么引入的这个类库？&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;为什么选择了这个版本？&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;为了回答这两个问题，我们先从介绍Maven开始。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;bom&quot;&gt;BOM&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;BOM(Bill Of Materials)实质上就是一个特别的POM，在这个POM中集中的定义项目的依赖和管理和更新他们版本。这个就把管理和更新依赖及其版本的职责集中到一处统一管理、测试以及发布，其他项目只要依赖这个POM就省去了每个人都要考虑使用那个依赖的那个版本的问题。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;BOM一般有两种使用方式，&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;一种是直接通过pom.xml中的parent节点继承，一个项目只能有一个parent，这种常见的是一个组织内部自定义的BOM。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;listingblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-dependencies&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.5.4&amp;lt;/version&amp;gt;
    &amp;lt;relativePath/&amp;gt;
&amp;lt;/parent&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;另一种方式是在pom.xml中的dependency management中使用import pom的方式引入。 这个没有数量的限制，常见的第三方类库都可以通过这种方式管理。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;listingblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&amp;lt;dependencyManagement&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-dependencies&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.5.4&amp;lt;/version&amp;gt;
        &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
        &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;colist arabic&quot;&gt; 
   &lt;table&gt; 
    &lt;tbody&gt;
     &lt;tr&gt; 
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt; 
      &lt;td&gt;type指定为pom&lt;/td&gt; 
     &lt;/tr&gt; 
     &lt;tr&gt; 
      &lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt; 
      &lt;td&gt;scope指定为import&lt;/td&gt; 
     &lt;/tr&gt; 
    &lt;/tbody&gt;
   &lt;/table&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;继承parent&quot;&gt;继承(Parent)&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;pom.xml中声明parent节点之后，就是当前项目pom会继承指定的parent节点中的项目。 所谓的继承，也没啥特别的，其实就是一个把父项目中内容拷贝合并到子项目中的意思。只不过在拷贝合并的过程中，子项目中的元素会覆盖(overwrite)父项目中的相同元素。 而且一个项目只能有一个parent项目，这是不是和Java语言中的类的单继承机制很像？&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;所以maven编译的时候就是直接递归的把当前项目的所有父项目的pom.xml内容依次拷贝到子项目的pom.xml文件中，同时在这个拷贝合并的过程中应用上面的覆盖原则。 之后就生成了一个effective pom，效果相当于执行如下命令：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;listingblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell script&quot; data-lang=&quot;shell script&quot;&gt;mvn help:effective-pom&lt;/code&gt;&lt;/pre&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;传递依赖transitive_dependencies&quot;&gt;传递依赖(Transitive Dependencies)&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;传递依赖是说当前项目能够自动的把它依赖的类库的依赖引入过来。这样就省去了当前项目重复的逐个申明依赖的类库。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;假设有A项目申明了依赖B，而项目B申明了依赖C，D和E：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2021/09/images/deps.svg&quot; alt=&quot;A只申明了依赖B&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 1. A只申明了依赖B
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;应用依赖传递之后，项目A实际上是依赖的B，C，D和E。效果等同下图：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2021/09/images/deps-resolved.svg&quot; alt=&quot;A实际上依赖了B，C，D，E&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 2. A实际上依赖了B，C，D，E
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这里面还涉及一个依赖的scope的问题，会影响依赖的传递，先不细说了，也不影响理解依赖的传递。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;依赖管理dependency_management&quot;&gt;依赖管理(Dependency Management)&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;BOM中dependencyManagement元素就是集中定义依赖及其版本的地方，这样使用这个BOM的项目就不需要在单独定义版本了。而且dependencyManagement元素中的依赖只有用到了才起作用，也就是出现在dependencies节点中的时候，这时候就不用指定依赖的版本号了。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;quoteblock&quot;&gt; 
   &lt;blockquote&gt;
     Dependency management - this allows project authors to directly specify the versions of artifacts to be used when they are encountered in transitive dependencies or in dependencies where no version has been specified. In the example in the preceding section a dependency was directly added to A even though it is not directly used by A. Instead, A can include D as a dependency in its dependencyManagement section and directly control which version of D is used when, or if, it is ever referenced. 
   &lt;/blockquote&gt; 
   &lt;div class=&quot;attribution&quot;&gt;
     — Maven
    &lt;br&gt; &lt;cite&gt;https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html&lt;/cite&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;dependencyManagement元素中定义的依赖及其版本是能够直接控制传递依赖和没有指定版本的依赖的版本的。但是如果是当前项目的pom.xml的dependencies节点中直接申明的带版本的依赖，则不受dependencyManagement中定义的版本控制。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;假如项目A中直接依赖了B，通过B间接依赖的2.0版本的C，如下图：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2021/09/images/deps-version.svg&quot; alt=&quot;A项目的传递依赖C(2.0)&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 3. A项目的传递依赖C(2.0)
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这时候如果 dependencyManagement元素中直接定义了1.0版本的依赖C，那最终A项目依赖的C是1.0版本的：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2021/09/images/deps-version-resolved.svg&quot; alt=&quot;A项目的实际依赖C(1.0)&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 4. A项目的实际依赖C(1.0)
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;依赖协调dependency_mediation&quot;&gt;依赖协调(Dependency Mediation)&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;我们知道一个依赖可以通一个三元组(groupId:artifactId:version)来确定, 其中的groupId:artifactId组合用来区分不同的依赖，同一个依赖则是用version来确定用哪一个。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这里面的version没有具体的规范，就是一个字符串, 所以Maven不知道同一个依赖的不同版本哪个是新的，那个是旧的。因此有多个版本的时候不是选用最新的版本，而是选当前项目的依赖中最近的声明版本(nearest definition)。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;quoteblock&quot;&gt; 
   &lt;blockquote&gt;
     Dependency mediation - this determines what version of an artifact will be chosen when multiple versions are encountered as dependencies. Maven picks the &quot;nearest definition&quot;. That is, it uses the version of the closest dependency to your project in the tree of dependencies. You can always guarantee a version by declaring it explicitly in your project’s POM. Note that if two dependency versions are at the same depth in the dependency tree, the first declaration wins. 
   &lt;/blockquote&gt; 
   &lt;div class=&quot;attribution&quot;&gt;
     — Maven
    &lt;br&gt; &lt;cite&gt;https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html&lt;/cite&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;把当前项目的依赖组织成一棵树, 姑且称之为依赖树，寻找最近申明的依赖的过程就是广度优先(BFS)遍历这棵树，遇到遍历过的依赖就剪枝，删除包含遍历过的节点以及其子树。这样就是在依赖树中寻找到当前项目的最短路径的依赖，而相同层级的话，也优先使用了最先遇到的。这里面也隐含了依赖申明顺序的问题，稍后说明。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;假设项目A的依赖关系如下图，对于D这个依赖来讲，应用nearest definition原则，Maven最终会选用的版本是D(2.0)。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2021/09/images/deps-version-tree.svg&quot; alt=&quot;项目A的依赖树&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 5. 项目A的依赖树
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;依赖优先级&quot;&gt;依赖优先级&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;整个依赖管理中的优先级从高到低依次如下：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;olist arabic&quot;&gt; 
   &lt;ol class=&quot;arabic&quot;&gt; 
    &lt;li&gt; &lt;p&gt;项目的dependencies中直接声明的依赖及其版本，一般同一个项目中不会申明相同依赖的不同版本，如果出现的话，优先使用先申明的依赖；&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;parent项目的dependencies节点中申明的依赖及其版本(参考上面的继承)；&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;import pom中申明的依赖及其版本，import pom的顺序很关键，如有依赖有版本冲突，按照声明的顺序依次使用；&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;当前项目的间接传递依赖及其版本。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ol&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;总结下来就是不同优先级的按照从高到低的优先级，相同优先级的按照他们的申明顺序从上到下(pom.xml文件解析顺序，也就是依赖申明顺序)。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;按照这个优先级，如果你发现有依赖的版本不符合预期，则可以通过这个优先级顺序在合适的地方直接申明想要的依赖就可以了。常见的我们就会直接在当前项目的pom.xml中直接申明一下需要使用的版本就可以了。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这个优先级以及顺序，也是构建依赖树的优先级和顺序。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;常用排查命令&quot;&gt;常用排查命令&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;查看依赖树&quot;&gt;查看依赖树&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;查看依赖树是非常常用的，这里除了默认的文本输出，还可以使用outputType参数来指定格式如graphml,dot等，接着就可以可视化的展示依赖树了。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;listingblock&quot;&gt; 
    &lt;div class=&quot;content&quot;&gt; 
     &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell script&quot; data-lang=&quot;shell script&quot;&gt;mvn dependency:tree -DoutputType=graphml -DoutputFile=dependency.graphml&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;查看依赖使用情况&quot;&gt;查看依赖使用情况&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;分析依赖使用与否的情况，貌似不太准确，参考就可以了。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;listingblock&quot;&gt; 
    &lt;div class=&quot;content&quot;&gt; 
     &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell script&quot; data-lang=&quot;shell script&quot;&gt;mvn dependency:analyze&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;整个Maven依赖管理以当前项目为中心分为2部分，当前项目以上部分适用继承合并pom.xml，当前项目以下的依赖部分适用传递依赖与最短申明距离的依赖协调机制。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2021/09/images/deps-tree.svg&quot; alt=&quot;项目树&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 6. Maven项目树
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;通过以上分析，就能回答前面提出的2个问题，并且解决版本冲突的问题。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;JRebel 2021 Java Developer Productivity Report, &lt;a href=&quot;https://www.jrebel.com/resources/java-developer-productivity-report-2021&quot; class=&quot;bare&quot;&gt;https://www.jrebel.com/resources/java-developer-productivity-report-2021&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Introduction to the Dependency Mechanism, &lt;a href=&quot;https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html&quot; class=&quot;bare&quot;&gt;https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Spring with Maven BOM, &lt;a href=&quot;https://www.baeldung.com/spring-maven-bom&quot; class=&quot;bare&quot;&gt;https://www.baeldung.com/spring-maven-bom&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>苹果APP开发的安全机制</title>
                <link>https://www.reploop.org/blog/2021/08/apple-app-publish.html</link>
                <pubDate>Thu, 19 Aug 2021 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2021/08/apple-app-publish.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;众所周知，苹果的应用商店是苹果自己的独家的，而且也不允许第三方应用商店的存在。所以开发者想要让苹果手机用户能用自己的应用，就必须要遵守苹果的规则。现在我们从苹果的角度看一下，苹果要如何做到这个呢？核心就是 &lt;strong&gt;数字签名&lt;/strong&gt;，而数字签名的基础就是 &lt;strong&gt;非对称加密&lt;/strong&gt;。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;非对称加密&quot;&gt;非对称加密&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;非对称加密(RSA)数学原理以及证明的过程主要是欧拉函数和中国剩余定理，其安全性以及证明暂时略去。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;RSA工作起来就是生成一对公钥和私钥，这一对密钥有个重要的特性是公钥加密的数据只能用配对的私钥解密；反过来，私钥加密的数据也只能用配对的公钥解密。这样就可以放心的把公钥公开，然后私钥自己安全的保存起来。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;大部分的加密过程是使用公钥加密数据，然后使用私钥解密数据。这样就允许了不共享密钥的情况下，让许多人可以安全的发送数据。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;数字签名&quot;&gt;数字签名&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;数字签名其实也是RSA，只不过是用私钥加密数据。因为私钥是安全保存，不对外公开的，如果私钥对应的公钥能够解密这个密文，我们就知道这个数据一定是私钥的拥有者发出来的。这也是数字签名的本意，证明数据的归属。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;苹果应用商店的规则&quot;&gt;苹果应用商店的规则&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;苹果要求应用开发者必须先注册成功苹果的开发者，然后开发者所开发的APP必须经过苹果的审核才能安装到苹果设备上。也就是：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;olist arabic&quot;&gt; 
   &lt;ol class=&quot;arabic&quot;&gt; 
    &lt;li&gt; &lt;p&gt;认证过的开发者才能发App&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;App必须经过苹果的审核&lt;/p&gt; &lt;/li&gt; 
   &lt;/ol&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;但是APP开发都有一个开发测试的过程，这期间APP会频繁的变化，都要审核吗？不需要。苹果的解决方案是可以不经过苹果审核，但是限制APP只能安装到一定数量的已知设备(Device)上用来测试。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这样整个流程就涉及开发者、苹果、设备以及APP。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这两个过程都需要用到数字签名。苹果和开发者各自都有自己的公钥和私钥对，苹果在这个过程中还充当了CA的角色。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;开发者&quot;&gt;开发者&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;首先开发者需要有一对公钥和私钥。然后把公钥交给苹果签发一个证书。这就是苹果认证过的开发者凭证了。 这个证书是可以用到签名APP签名的过程。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;苹果&quot;&gt;苹果&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;苹果也有自己的公钥和私钥对。苹果审核过的APP可以通过苹果的私钥进行签名，安装过程中使用设备上已经预置的公钥进行验证。通过就能肯定这是苹果签发的APP的。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;这样就控制了App的生命周期。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;&lt;a href=&quot;https://www.reploop.org/blog/2020/03/how-https-works.html&quot;&gt;HTTPS如何工作的?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;iOS App 签名的原理, &lt;a href=&quot;http://blog.cnbang.net/tech/3386/&quot; class=&quot;bare&quot;&gt;http://blog.cnbang.net/tech/3386/&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>一些客户端的实现方案</title>
                <link>https://www.reploop.org/blog/2021/07/some-clients-implementions.html</link>
                <pubDate>Sat, 3 Jul 2021 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2021/07/some-clients-implementions.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;对于需要通过网络传输进行交互的服务，都有一个称之为客户端或者驱动(driver)的来实现不同服务的应用层的协议解析处理。比如MySql，Couchbase， Redis， MongoDB， Memcached和MQ等等都有对应的驱动或者各种语言实现的客户端。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;而每种客户端的实现都有各自的考虑，有些是服务端的特点决定的，有些是实现者所推崇的软件哲学起主要作用。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;客户端设计的逻辑&quot;&gt;客户端设计的逻辑&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;客户端的最主要的职责是实现其对应的服务要求的应用层协议。除此之外，互联网应用基本上对应了集群的环境，意味着服务端一般来讲都会有多台机器组成的。那么客户端的另外一个关键因素就是基于每次请求，决定发送给哪些机器。这块实现的好坏直接决定了你的睡眠质量。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;jdbc&quot;&gt;JDBC&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;连接关系型数据库的时候都离不开JDBC，这个大概也是大家最早接触也是最熟悉的了。JDBC是一个非常基础的应用层协议，负责把SQL发送给服务端，然后按照基础的行结构读取结果。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;使用关系数据库的时候，一个应用使用到的类库可能非常多：&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;ulist&quot;&gt; 
    &lt;ul&gt; 
     &lt;li&gt; &lt;p&gt;ORM框架，&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;连接池,&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;分库分表的框架，&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;读/写分离&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;集群支持&lt;/p&gt; &lt;/li&gt; 
    &lt;/ul&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;也就是JDBC本身的定位和实现是简单的，这些都是应用开发者该考虑的问题。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;redis的实现逻辑&quot;&gt;Redis的实现逻辑&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;Redis 2.x系列的Java客户端的实现基本上只是负责Redis协议的解析执行。他实现的时候也不关心线程安全性，认为这是开发着的职责；也不关心网络错误处理，只汇报必要的错误，留给开发者处理。同时，也不能感知服务端的拓扑变化，你指定哪个IP我就去连接，这个IP宕了，我就告诉你连不上了。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;没错，说的就是Jedis客户端。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;mongodb的实现逻辑&quot;&gt;MongoDB的实现逻辑&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;MongoDB的官方客户端实现相比Jedis则考虑的因素变得非常多了。客户端知道整个服务拓扑结构，还实现了客户端的连接池以及基于统计的服务端节点选择器。比如统计响应时间（RTT）最短的服务器来发送请求。这时候的服务节点不仅仅是一个IP信息，而且包含了更多的附加属性，如tagSet，角色等给了客户端更多的数据供决策。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;cassandra&quot;&gt;Cassandra&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;Cassandra的客户端不仅仅能知道整个服务的拓扑结构，而且也能知道一部分数据结构。这当然是和Cassandra整个服务的设计有关，但是这个客户端基本上能做的事情非常多，比如客户端负载均衡等等。这样一个客户端就做了很多事情，可以让应用开发者专注在应用上。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;上面的几个客户端可以看出，在越来越多的面对分布式，大数据量的场景下，客户端掌握的数据越来越多了，实现也是越来越重了，越来越多的功能和特性都落在客户端了。而微服务的发展，客户端的职责也更多了。比如说服务发现，服务路由，限流，调用链，统计分析等等都是在客户端的参与下完成的。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>基于角色的权限与认证</title>
                <link>https://www.reploop.org/blog/2021/06/a-brief-introduce-to-rbac.html</link>
                <pubDate>Mon, 28 Jun 2021 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2021/06/a-brief-introduce-to-rbac.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;权限管理管理涉及用户，操作和资源，主要就是回答&quot;用户-操作-资源&quot;是不是被允许的。这就通过现实中的&quot;主-谓-宾&quot;的形式定义了一个完整行为，权限管理就是决定这个行为是不是被允许的。给出这个理解，实现一个权限管理最简单的做法就是三个实体表再加一个权限的关联表。这个关联表每条记录都包含了用户，操作，资源，是否允许这几个关键属性。这个表的数量是一个笛卡尔乘积 = &lt;strong&gt;用户数*操作数*资源数&lt;/strong&gt;。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;在数量相对较少的情况下这个方案不管是授权还是鉴权都很简单，但是当数量稍微多一点之后授权成本对人来说就太大了。比如一个1000人企业内部的WIKI权限系统，划分了不同的团队空间200个，对团队空间的操作有4个（仅仅考虑最简单的CRUD），那么这个管理复杂度：1000*4*200=80万。这对计算机来说不足为虑了，对那个要进行权限管理的管理员来说负担大的是个不可能完成的任务。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;从这里演化出2个重要概念，组(Group)和角色(Role)，用他们能大大降低授权的工作量。以下是权限管理中涉及到的实体，先说明一下方便后面讨论。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;名词解释&quot;&gt;名词解释&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;dlist&quot;&gt; 
   &lt;dl&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     用户(User)
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;最好理解的是用户，这就是上面提到的行为的主体，可以是各种需要权限的人等，比如员工等。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     资源(Object)
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;受权限保护的资源，常见的比如数据库注册用户表， WIKI，代码仓库等等。资源是操作的对象。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     操作(Operation)
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;对资源的操作，细粒度的比如创建(Create)，读取(Read)，更新(Update)，删除(Delete)，合起来就是常说的CRUD。&lt;/p&gt; 
    &lt;/dd&gt; 
   &lt;/dl&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;以上三个实体可以认为是最基础的实体，权限管理过程中其他实体都是他们各自或者相互结合之后演化出来的。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;dlist&quot;&gt; 
   &lt;dl&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     组(Group)
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;相同的实体合在一起形成组，多用户可以成为用户组，多资源可以成为资源组，多操作可以成为操作组。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     权限(Permission)
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;权限是操作和资源的组合。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     角色(Role)
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;角色是通过该角色所具备的权限来定义的，也就是多个操作和资源的组合定义为一个角色，反过来角色代表了一些操作和资源的有效组合。比如我们常说的数据库管理员，就代表了对数据库这个资源组进行所有操作的角色。通过将角色赋予某个用户从而使得某个用户具有了角色所代表的权限。用组(Group)的概念来说，角色就是多个权限形成的权限组，称他为角色。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     授权(Authorization)
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;授权就是将用户、操作和资源通过角色关联起来，也就是生成权限的过程，进一步可以扩展为权限管理。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     鉴权(Authentication)
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;鉴权是判定正在进行的行为是否被允许的过程。&lt;/p&gt; 
    &lt;/dd&gt; 
   &lt;/dl&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;实体关系&quot;&gt;实体关系&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;有了上面的解释说明，我们现在就可以理解他们之间的关系了：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2021/06/images/auth.svg&quot; alt=&quot;实体关系图&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 1. 实体关系图
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;有了角色和组的概念之后，就可以实现分阶段的批量授权了：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;olist arabic&quot;&gt; 
   &lt;ol class=&quot;arabic&quot;&gt; 
    &lt;li&gt; &lt;p&gt;角色定义：前面我们说角色就是一个权限组，代表了多个权限的组合。这样我们就可以提前先把角色定义出来，通过这种一对多的关系来减少权限的数量，进而减少授权工作量。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;用户授权：将用户关联到特定的角色上，赋予用户该角色所具有的权限。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ol&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;除了角色，也可以利用 &lt;strong&gt;组&lt;/strong&gt; 把授权工作量进一步的降低，行为就会变为：用户组-操作组-资源组了，其他实体也可以做一样的考量。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;有些时候我们只是对操作授权，也就是是不能能访问某个API这种力度的ACL，一旦授权哪怕这个API需要依赖多个资源也是可以的。 比如一个网页上不同的模块需要操作不同的数据，这时候该怎么管理权限呢？&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;一种做法就是识别出模块中的所有资源，分别细粒度的管理，&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;一种就是针对URL进行粗粒度的授权,&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;还有一种中间状态，就是考虑把模块抽象为资源进行授权。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;权限管理实现的层次不同可以让这种授权也变为可能。假设一个应用的拓扑层次是：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2021/06/images/top.svg&quot; alt=&quot;应用拓扑图&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 2. 应用拓扑图
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;鉴权的过程我们可以选择在任意一层或者多层来实现，这样就可以通过定义丰富的资源(比如API，URL作为资源)来实现权限管理了。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;在这里的关系都是多对多的，从任意一个实体看过去，都是一个一对多的关系。 也就是一个用户可以属于多个用户组，一个用户组可以包含多个用户；同样的一个权限可以属于多个角色；一个角色也可以包含多个权限。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;冲突解决&quot;&gt;冲突解决&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这样就带来一个问题，比如一个用户有多个角色，角色中相同资源的操作是不一样的，也就是权限有重复定义了。 面对这种情况常见的是使用 &lt;strong&gt;最小权限原则&lt;/strong&gt; 来决定具有哪个权限。这里需要应用策略来解决问题。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;权限继承&quot;&gt;权限继承&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;人的组织，尤其是公司内人的组织一般是一个树形的组织结构，需要针对树形中不同层次的范围进行权限管理。 一个方案是让角色具有这种层级关系，并且有继承关系的；另一个是让用户就是这种层次关系，同时也继承权限。基于角色的权限管理一般是角色具有这种层次关系。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;从用户-操作-资源这个行为出发逐步理解基于角色的权限系统设计过程中面临的挑战以及相应的解决方案，有助于理解外面各种开源权限系统，也能帮助设计内部系统的权限认证系统。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这里面的资源是作为一个整体来进行管理的，其实资源可以进一步细分为不同的属性，然后对属性进行访问控制。使用过OAuth的大概是都知道一个scope的概念，比如可以针对用户的name和email进行鉴权。这种可以归为Attribute based Access Control aka ABAC，以后在分析一下。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>Netty 4 线程模型</title>
                <link>https://www.reploop.org/blog/2020/08/netty-4-thread-model.html</link>
                <pubDate>Wed, 12 May 2021 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2020/08/netty-4-thread-model.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;Netty 4 的线程模型核心是一个连接(channel)一个线程(thread)，但是一个线程可以绑定到多个不同的连接。也就是每一个连接上的所有I/O事件都是一个线程(EventLoop)来执行的，这个线程也可以叫I/O线程。这样从连接的角度看就是一个连接一个线程的单线程模型，省去了多线程同步的代价，写起代码简单可靠；从线程的角度看一个线程可以管理多个连接，工作起来也不需要大量的线程。当遇到业务逻辑比较耗时的情况，Netty允许这部分工作交给单独的线程池(EventExecutor)执行，执行完成产生的事件在通过提交到连接绑定的线程工作队列中，回到I/O线程中来继续流转。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;netty线程池&quot;&gt;Netty线程池&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;简单朴素的正向思路，线程池就是提前实例化多个线程，有任务的时候呢，先挑一个线程出来，然后把任务给它执行。有过数据库连接池使用经验的话，应该很熟悉这种模式。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;listingblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;int size = 100;
Thread[size] = new Thread[size]; //线程池&lt;/code&gt;&lt;/pre&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;注：这里面的size如何决定，请参见 &lt;a href=&quot;https://www.reploop.org/blog/2020/05/how-to-size-thread-pool.html&quot;&gt;如何设置线程池的大小&lt;/a&gt;。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;不过Doug Lea大神在Java 1.5提供的线程池实现则不是这么简单粗暴，而是通过Executor抽象把线程池这部分透明化了，变成了提交一个异步任务，得到一个代表执行结果的Future对象。 这样就不需要处理线程同步、等待等问题了。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;理解Java的线程池实现对理解Netty的线程模式非常有帮助，因为Netty里面是自己定制实现了一个Executor。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;实现思路&quot;&gt;实现思路&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;Netty中的Executor实现有2中，一个是EventLoop，一个是EventExecutor。EventExecutor更像是Java中的Executor，用来多线程执行业务代码，而EventLoop是EventExecutor的特殊实现，它是绑定到Channel上的。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;EventLoop和channel之间的关系是一个channel只能注册到一个EventLoop，而一个EventLoop可以绑定到多个Channel。 每个EventExecutor都会绑定唯一的一个线程，并且可以有0或者1个工作队列（EventLoop）。提交任务的时候将任务放去工作队列，而绑定的线程则不停地轮询（Loop）工作队列，如果有任务则执行，没有就等待，直到Executor关闭才退出循环。EventExecutor和JDK中的线程池Executor非常类似的思想。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;延迟绑定&quot;&gt;延迟绑定&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;EventExecutor 第一次执行任务的时候，使用ThreadPerTaskExecutor创建一个新线程，并且绑定到这个EventExecutor。ThreadPerTaskExecutor非常特殊，没有工作队列，每个任务都是新创建一个线程去执行，顾名思义。而当前任务呢将作为这个线程的第一个任务去执行。一般来讲绑定任务都是个无限循环，不停地从当前的Executor的任务队列中拉取任务执行，直到停止或者关闭的时候才结束。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;netty事件模型&quot;&gt;Netty事件模型&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;Netty 4中的核心事件处理流程是下图这样的：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2020/08/images/netty-4-thread-model.png&quot; alt=&quot;Thread任务执行模型&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 1. Thread任务执行模型
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;从一个Channel建立开始，绑定一个EventLoop，通过一个由Handler顺序组成的Pipeline完成一次事件处理并返回结果（如果有必要的话）。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;多线程环境&quot;&gt;多线程环境&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;使用Netty的一个最佳实践就是不要阻塞I/O线程。那么应用自己的一部分比较耗时的逻辑该如何不阻塞I/O线程呢？&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;Netty是通过Pipeline中的每个Handler可以显式绑定一个Executor的方式来实现业务多线程执行，从而不阻塞I/O线程。如果没有绑定的话，就使用Channel默认绑定的EventLoop执行。每个Handler执行任何Read或者Write操作都会检查当前Executor和绑定的是否一致，如果一致的话，单线程直接执行任务；不一致，当前Executor将把操作封装成一个任务提交到下一个Executor的任务队列中。整体流程参考上图。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;Netty中默认都是使用的I/O线程，也就是Worker线程去执行任务，如果你的Handler里面有耗时任务，比如常见的网络操作，在加上一个EventLoop可以绑定到多个Channel，那么强烈建议给这个Handler显式绑定一个EventExecutorGroup，使得I/O线程能够继续处理I/O操作。如果阻塞当前线程的话，1个或者多个Channel将被阻塞，从而严重影响吞吐量。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;EventExecutor上创建的Promise或者Future，当前线程是用来阻塞等待的（wait/notify机制），实现的效果就是谁调用阻塞方法，就阻塞谁。但是当Promise和Future完成（notify）之后，是用这个EventExecutor去通知所有的监听者。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;EventExecutor可以看做一个普通的线程，去执行业务任务。EventLoop作为EventExecutor的特例，只用来执行I/O相关任务，因此也不能被阻塞。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;一些的注意点&quot;&gt;一些的注意点&lt;/h3&gt; 
   &lt;div class=&quot;olist arabic&quot;&gt; 
    &lt;ol class=&quot;arabic&quot;&gt; 
     &lt;li&gt; &lt;p&gt;NIO模式下，Netty中Channel和JVM的Channel是通过附件attachment关联起来的。&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;ByteBuf要在同一个线程里面创建和回收，从而避免内存泄露。因为ByteBuf Pool用的是ThreadLocal实现的。&lt;/p&gt; &lt;/li&gt; 
    &lt;/ol&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;New and noteworthy in 4.0 - &lt;a href=&quot;http://netty.io/wiki/new-and-noteworthy-in-4.0.html&quot; class=&quot;bare&quot;&gt;http://netty.io/wiki/new-and-noteworthy-in-4.0.html&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Upgrading a Reverse Proxy from Netty 3 to 4 - &lt;a href=&quot;https://medium.com/square-corner-blog/upgrading-a-reverse-proxy-from-netty-3-to-4-878ec407665a#.yyrawts8y&quot; class=&quot;bare&quot;&gt;https://medium.com/square-corner-blog/upgrading-a-reverse-proxy-from-netty-3-to-4-878ec407665a#.yyrawts8y&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;EventLoop → EventExecutor Lazy Bind - &lt;a href=&quot;http://www.infoq.com/cn/articles/netty-version-upgrade-history-thread-part&quot; class=&quot;bare&quot;&gt;http://www.infoq.com/cn/articles/netty-version-upgrade-history-thread-part&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>编程语言中的文件系统与命名空间的关系</title>
                <link>https://www.reploop.org/blog/2021/04/path-and-namespace.html</link>
                <pubDate>Thu, 29 Apr 2021 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2021/04/path-and-namespace.html</guid>
                <description>
                        &lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;编程语言的中命名空间非常重要，提供了语言层面的隔离，使得不同的人可以放心的写代码而不用担心名字冲突的问题。 编程语言写成的源代码都是写到文件里存储的，不同的文件本身也是一个隔离手段。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;源代码都是按照文件的方式存储的，用文件可以实现基本的隔离。但是为了多个文件之间共享代码，文件的方式就不太够用了，起不到隔离的作用的，就需要实现语言层面的隔离。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;为了实现语言层面的隔离，该命名空间发挥作用了。命名空间可以认为是物理文件之上更抽象的一个概念，保证在一个命名空间内名字不冲突。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;像Java语言大概只知道命名空间，也就是package。然后使用默认的类名必须和文件名一样的规则，package对应各个层次的文件夹，这种一一对应的好处就是你基本感觉不到文件系统的存在。所以在import的过程中只见package，不见文件路径。能感受到路径的是获取资源的时候，这相当于还是基于文件系统找资源。这时候又没有了命名空间的意思了。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;像Protobuf则是文件路径和命名空间同时存在。在一个文件引入另一个文件的时候使用的是文件路径。引入之后的，在需要使用具体的Message解析依赖的时候使用命名空间来隔离的。这两个可以是各自独立的。Ruby 也是一样的。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;文件系统的使用都有一个开始路径，选定这个锚点，从这个路径开始查找资源。这就衍生出一个绝对路径和相对路径。所谓绝对路径就是整个应用最顶层的文件路径开始查找。相对路径则是根据当前文件所在的路径作为基点开始查找资源。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;Java中查找资源常见的有2种方式：&lt;/p&gt; 
&lt;/div&gt; 
&lt;div class=&quot;listingblock&quot;&gt; 
 &lt;div class=&quot;content&quot;&gt; 
  &lt;pre&gt;String path = &quot;&quot;;
SomeClass.class.getResource(path);   &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
ClassLoader.getSystemResource(path); &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;第一种方式可以使用绝对或者相对路径查找，使用绝对路径的时候以 &lt;strong&gt;/&lt;/strong&gt; 开始，其他情况就是使用相对路径，也就从当前SomeClass的位置开始查找。相对路径实现起来也简单，就是把当前SomeClass的路径加到待查找路径的前面，形成新的路径去查找就可以了。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;第二种方式则只是用绝对路径查找，也就是从根目录开始查找。指定的查找资源路径也需要从根路径开始的路径，但是路径不需要以 &lt;strong&gt;/&lt;/strong&gt; 开始。&lt;/p&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>Java日期与时间的一些理解</title>
                <link>https://www.reploop.org/blog/2021/04/java-date-time.html</link>
                <pubDate>Thu, 22 Apr 2021 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2021/04/java-date-time.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;日期和时间是表达周期性运动的一种方式，反过来说所有的周期性运动都可以用来计算时间。 地球人都知道有2种周期性运动，一个是地球绕太阳的公转，一个是地球自身的自转。地球的公转决定了日期，也就是 &lt;strong&gt;年-月-日&lt;/strong&gt;。地球的自转决定了时间，也就是 &lt;strong&gt;时-分-秒&lt;/strong&gt;。我们所说的一年就是地球公转一圈的时间，一日就是地球自转一圈的时间。所谓的周期性就是这个意思。日期的最小单位 &lt;strong&gt;日&lt;/strong&gt; 就是地球自转一圈的时间，也就是24小时。 中国的农历和节气还和月球绕地球公转有关系。 而现在最精确的 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%AD%90%E9%90%98&quot;&gt;&lt;strong&gt;原子钟&lt;/strong&gt;&lt;/a&gt; 则是以原子共振频率标准来计算时间的。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;时间的表达&quot;&gt;时间的表达&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;Java中的日期和时间是时间在计算机中的结构化表达，比如 &lt;strong&gt;Date&lt;/strong&gt; 类内部就是用毫秒数表示的。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;毫秒数&quot;&gt;毫秒数&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;milliseconds 是一个和时区没关系的值，也就是同一时刻全世界不同地方同时通过以下代码获取到的毫秒数是一样的：&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;listingblock&quot;&gt; 
    &lt;div class=&quot;content&quot;&gt; 
     &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;System.currentTimeMillis();&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;其结果都是从 &lt;strong&gt;1970-01-01T00:00Z&lt;/strong&gt; 开始到现在的毫秒数。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;quoteblock&quot;&gt; 
    &lt;blockquote&gt; 
     &lt;div class=&quot;paragraph&quot;&gt; 
      &lt;p&gt;But the concept is the same - those values are &quot;absolute&quot;: they are the same for everyone in the world, no matter where they are. If 2 people in different parts of the world (in different timezones) get the current timestamp at the same time, they’ll all get the same number.&lt;/p&gt; 
     &lt;/div&gt; 
    &lt;/blockquote&gt; 
    &lt;div class=&quot;attribution&quot;&gt;
      — user7605325
     &lt;br&gt; &lt;cite&gt;https://stackoverflow.com/questions/46093200/showing-correct-time-from-milliseconds-with-desired-timezone&lt;/cite&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;Date， LocalDate，LocalDateTime 本身都是时间的结构化表达，本身并不带有时区信息。只需要需要给人展示的时候，才会用到时区信息来具体展示时间。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;locale与timezone&quot;&gt;Locale与Timezone&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;Locale是指所属的地区以及该地区的语言，而Timezone则是时区。 直觉上我们一直说的是中国的时区是东八区，所以在系统层面就理解地区和时区之间是有关系的，也就是设置了Locale则自动设置了该地区的时区。这也是我曾经的一个误解，其实他们两个之间是相互独立的。Locale作用于系统语言，比如国际化等。 TimeZone作用于日期和时间。 设置Locale不会影响日期与时间，反之亦然。如果非要有点关系的话，就是如果时间的字符串中有特殊语言，则可以使用Locale让系统知道，然后正确展示。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;时区的理解&quot;&gt;时区的理解&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;Java 1.8以前和Java 1.8中的日期和时间设计分别参考 &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/datetime/overview/index.html&quot;&gt;Java日期设计&lt;/a&gt; 与 &lt;a href=&quot;https://www.journaldev.com/2800/java-8-date-localdate-localdatetime-instant&quot;&gt;Java 8日期API&lt;/a&gt;。这里面的时区是采用标准的 &lt;a href=&quot;http://www.iana.org/time-zones&quot;&gt;时区数据库&lt;/a&gt;。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;utc与gmt&quot;&gt;UTC与GMT&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;先来看2段引用：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;quoteblock&quot;&gt; 
   &lt;blockquote&gt; 
    &lt;div class=&quot;paragraph&quot;&gt; 
     &lt;p&gt;To begin with, GMT (which stands for Greenwich Mean Time) is not the same as UTC (which stands for Coordinated Universal Time): GMT is a time zone used in some but not all parts of the world (mainly Europe and Africa). It uses either a 24-hour format or a 12-hour format for display and its based on astronomical observations. UTC is not a time zone. It is a standard which we can use to display time zones. It is more stable as it takes time from an atomic clock.&lt;/p&gt; 
    &lt;/div&gt; 
   &lt;/blockquote&gt; 
   &lt;div class=&quot;attribution&quot;&gt;
     — Theo
    &lt;br&gt; &lt;cite&gt;https://phrase.com/blog/posts/how-to-get-date-time-in-utc-or-gmt-in-java&lt;/cite&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;quoteblock&quot;&gt; 
   &lt;blockquote&gt; 
    &lt;div class=&quot;paragraph&quot;&gt; 
     &lt;p&gt;Did you know that there is a difference between GMT and UTC even though they share the same current time? In short, GMT is an actual time zone, whereas UTC is a time standard that is used to keep time synchronized across the world.&lt;/p&gt; 
    &lt;/div&gt; 
   &lt;/blockquote&gt; 
   &lt;div class=&quot;attribution&quot;&gt;
     — UTC vs GMT
    &lt;br&gt; &lt;cite&gt;https://www.worldtimeserver.com/learn/utc-vs-gmt/&lt;/cite&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;也就是GMT(Greenwich Mean Time)是时区，但UTC(Coordinated Universal Time)不是时区，而是一个用来同步时间的标准。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;举例来说 &lt;strong&gt;GMT+8&lt;/strong&gt; 是时区，但 &lt;strong&gt;UTC+8&lt;/strong&gt; 不是时区，虽然他们说的同一个时间。UTF+8是一个offset，一个offset不能自动转为时区。Java 1.8的java.time包中提供了 &lt;strong&gt;ZoneOffset&lt;/strong&gt; 可参考。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;Java语言中展示时间的时候就用 &lt;code&gt;TimeZone.getTimeZone()&lt;/code&gt; 去解析并查找标准时区，这是按照时区去检索的，检索不到的话就是默认为 &lt;strong&gt;GMT&lt;/strong&gt; 时区。所以如果你输入UTC+8这个非法时区参数，得到的结果是GMT, 这就和GMT+8差了8个小时了，所有GMT+8不能用UTC+8代替。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;默认时区&quot;&gt;默认时区&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;现在基本上容器是必须要支持的运行环境，也就是有可能环境不再是私有的物理环境，不受开发控制的情况也经常发生。比如你使用了公有的镜像之类的。这种不受开发控制的环境，就需要通过外部参数来控制系统默认时区。其中的一种做法是通过系统属性 &lt;strong&gt;user.timezone&lt;/strong&gt; 的方式在JVM启动的时候来设置：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;listingblock&quot;&gt; 
   &lt;div class=&quot;title&quot;&gt;
    启动参数设置系统默认时区：
   &lt;/div&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;java -Duser.timezone=Asia/Shanghai Main&lt;/code&gt;&lt;/pre&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;其他方案参考这篇 &lt;a href=&quot;https://www.baeldung.com/java-jvm-time-zone&quot;&gt;文章&lt;/a&gt;。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>支付API为啥那么麻烦？</title>
                <link>https://www.reploop.org/blog/2021/03/pay.html</link>
                <pubDate>Sat, 20 Mar 2021 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2021/03/pay.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;仅仅在API层面，不涉及财务会计，金融监管等等方面，仅仅从安全角度考虑，支付API的大部分繁琐工作都在保证 &lt;strong&gt;你就是你&lt;/strong&gt; 的身份问题。 这个在新接入一家支付通道的时候感受非常明显。身份问题典型的解决方案就是基于非对称加密的 &lt;strong&gt;数字签名&lt;/strong&gt; 技术。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;支付安全&quot;&gt;支付安全&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;在一个支付流程中可能涉及的角色有平台用户，商户，平台，应用，商户用户等。整体上是一个三方参与的过程，比较复杂。支付也是一个异步流程，从商家的角度至少需要2步以上才能完成支付：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;olist arabic&quot;&gt; 
   &lt;ol class=&quot;arabic&quot;&gt; 
    &lt;li&gt; &lt;p&gt;首先是商家调用平台API发起支付&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;平台引导用户在平台上完成支付&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;平台向商家发起支付结果通知的回调请求。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ol&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;用户在支付平台上付款的事情是支付平台自己处理的，作为没有支付牌照的商家是不需要操心这部分的，暂时略过。 剩下的两步骤都需要请求发起方向请求接收方证明 &lt;strong&gt;你就是你&lt;/strong&gt;.&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;olist arabic&quot;&gt; 
   &lt;ol class=&quot;arabic&quot;&gt; 
    &lt;li&gt; &lt;p&gt;商家调用平台API发起支付的时候的得告诉平台是谁在收钱。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;平台向商家发起回调请求的时候商家需要知道是平台在发起回掉。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ol&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;只有这样商家才放心说钱一定会收到的(毕竟每笔交易你都没查银行账户确认)，平台也有凭证说商家已经把钱收了，用户确信商家是会履约的。这是一个双向的严格的安全要求。这就是为啥调用支付API要申请应用，要生成证书，要验签名等。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;第1个商家向平台证明自己的身份使用OAuth相关的技术。以支付宝为例，你要对接先申请一个应用，拿到一个APP ID和APP Secret，熟悉OAuth的人可能都马上能联系到开放平台的事情。APP Secret一定要保管好，不能泄漏。 貌似这一步也可以支持证书认证。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;第2个平台向商家证明自己的身份使用证书相关的技术。这就是我们需要下载平台的支付证书（其实是个公钥）的原因。这是用来回调验证签的。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;严格来收这里面并没有用到想HTTPS那样的证书，而仅仅是非对称加密算法中的公钥-私钥的密钥对，然后这就是一个数字签名的过程。不像HTTPS，这中间也没有知名的证书机构(CA)参与。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;https不能保证这个吗&quot;&gt;HTTPS不能保证这个吗？&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;虽说HTTPS逐渐普遍起来了，但是也不能完成保证支付安全的问题。因为HTTPS只能保证请求接收方的身份问题，不能确认请求发起方的身份问题。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;exampleblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;div class=&quot;paragraph&quot;&gt; 
     &lt;p&gt;注：其实HTTPS也支持客户端证书，开启之后就可以完成双向证书验证了。不过大部分情况下只是用服务端证书，而不启用客户端证书。&lt;/p&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;以支付宝为例，也就是是说我们访问 &lt;a href=&quot;https://openapi.alipay.com/gateway.do&quot; class=&quot;bare&quot;&gt;https://openapi.alipay.com/gateway.do&lt;/a&gt; 成功后请求发起方能确认访问的就是支付宝的支付接口，但是支付宝支付平台不能安全的知道是谁在发起支付请求。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;相应的支付回调也是类似的，支付宝发起HTTPS的回调，只能知道是访问了商家的回调地址，而商家不能安全的确信这就是支付宝发起的回调。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;而且上面的方案在非HTTPS的环境也是可以工作的。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;reploop.org - &lt;a href=&quot;https://www.reploop.org/blog/2020/03/how-https-works.html&quot;&gt;HTTPS如何工作的？&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>如何讨论一个问题？</title>
                <link>https://www.reploop.org/blog/2020/09/discuss-a-problem.html</link>
                <pubDate>Sat, 5 Sep 2020 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2020/09/discuss-a-problem.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;如何和不同的人讨论一个问题？尤其是两个专业领域不同，背景不一致，坐下来讨论一个共同问题，并最终达成共识，然后在后续的执行过程中能够达到预期的结果，是一个很难的问题。每个人专业领域不一样，看问题的视角也不一样，接受信息的能力或者意愿也不一样，处理信息的方法也不一样，好好讨论问题并达成共识。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;先看一下看问题的视角。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;视角&quot;&gt;视角&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;从创业公司层面的角度来看，做一个决策可能涉及到的考虑因素有：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;市场&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;运营&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;品牌&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;技术&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;财务&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;公司&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;文化&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;认知&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;用户&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;需求&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;产品&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;经济&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;宏观&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;行业&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;人力&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;商业&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;管理&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;人性&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;信仰&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;暂时不讨论他们之间的关系，也不把他们归类，只是把他们列出来看看。在这种情况下针对一个问题开始讨论了, 讨论的目的当然是要作出各方都认可的决策。那么可能发生的讨论过程是这样的：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;你按照市场决策，他说财务是关键。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;你按照技术决策，他说市场不等人。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;你按照品牌决策，他说产品更重要。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;依次类推。。。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这种场景最常见的就是某一个领域的下属和横向业务上的领导讨论问题时发生，最后屁股坐的正的说就这么办，之前的讨论就结束了。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;到了执行环节，下属将信将疑的免强做了动作，最后结果一汇报上去，领导不满意，还说你不专业。结果变成一个双输的局面。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;人们常说&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;quoteblock&quot;&gt; 
   &lt;blockquote&gt;
     唯一不变的就是变化。 
   &lt;/blockquote&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;我个人认为套用在和人相关的事情上都可以。如果你认同这句话，那就是要时刻准备接受变化，比如你读了更多的书，做了更多的项目，和更多的人接触，写了更多的代码，吃了更多的垃圾食品等等。现在让我们回到主题上了，这些变化会影响你看问题的角度，也就是会影响你作出决策，也就是之前的结论会变的。 剩下的问题就是变化有多快的事情了。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;假设 \$x\$ 为视角，\$w\$为视角的权重。那么讨论问题做出决策就可以表达为下面这个公式：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;stemblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt;
     \$f(x) = sum_(i=1)^n w_ix_i\$ 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;其中的权重制约关系为：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;stemblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt;
     \$1 = sum_(i=1)^n w_i\$ 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;所以变化部分其实就是某个视角的权重是变化的，各个视角的权重分配是动态变化的。随着人的专业，认知，经验等等发生变化，每个人对这个公式中视角的权重分配也是变化的，所以一个结论发生变化，实在是常有的事情。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;在这个结论下，一定要打开思路，敞开胸怀接受变化的发生，并积极想想如何应对变化了。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;那是不是就由着变化不停的变化吗？ 应该也不是。每个行业或者领域都是发展的，所以这个行业或者领域的变化应该是收敛的。所谓发展，就是迭代试错，不断地积累成功的经验规律。 在一定的周期内，随着行业的发展，每个视角的权重配比差不多达到一个最优的了，这就最终转化为行业的认识或者基本规律了。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;讨论一个问题，可能从量变与质变，定量与定性，过程与结果，存量与增量，绝对与相对等等多角度思考。 过程中要接受变化，并且认认真真的学习变化，最终收敛变化，完成一次迭代。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>小学数学在工作中应用</title>
                <link>https://www.reploop.org/blog/2020/05/primary-school-mathematics-in-work.html</link>
                <pubDate>Mon, 4 May 2020 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2020/05/primary-school-mathematics-in-work.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;作为一个Java程序员，干Web相关的开发，除去具体的业务，实质上干的就是通讯的工作，通过网络在不同机器之间来回搬字节（byte）。这么一比较，Java Web程序员的工作某些部分其实和大街小巷里面穿梭的快递员有几分相似。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;回到正路，日常工作中经常会碰到一些数字，需要给出合理的数值。这些数字可能是垃圾回收（GC）的频率，内存（Heap）的大小，线程池（Thread Pool）的大小，对象池（Object Pool）的大小，网络超时（Timeout）时间，压缩阀值等等。都是些应用层的东西，再往下深入到操作系统，协议层面的东西不知道小学数学还适用不适用了。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;gc的频率&quot;&gt;GC的频率&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;GC的频率与内存的大小息息相关，如果一个JVM的应用不正常，首要查看的可能就是GC状态。GC，尤其是FGC频繁一定是JVM目前不在正常状态，但是反过来不见的是成立的，这还要取决于你对频繁的理解。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;GC调优的过程中会频繁的遇到下面三个数据，并且这些数据都可以通过 gc log分析计算出来：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;olist arabic&quot;&gt; 
   &lt;ol class=&quot;arabic&quot;&gt; 
    &lt;li&gt; &lt;p&gt;内存分配速度(allocate rate)&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;新老晋升速度(promote rate)&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;内存回收速度(reclaim rate)&lt;/p&gt; &lt;/li&gt; 
   &lt;/ol&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;一般来说调优就是为了减少应用的停顿时间(stop-the-world time), 在一般应用内存也就是最多几个G的的情况下，可以间接的通过降低GC频率来做到。 这时候我们加入时间参数 &lt;strong&gt;t&lt;/strong&gt;， 所谓调优就是使得 &lt;code&gt;allocate rate * t &amp;lt; reclaim rate * t&lt;/code&gt;，只要时间确定的情况下，就可以通过计算来确定新生代和老年代的大小使得他们满足这个不等式就可以粗略的达到以时间 &lt;strong&gt;t&lt;/strong&gt; 为间隔发生GC，也就达到了预期的GC频率。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;对于老年代来说 promote rate可以粗略的认为是他的allocate rate。 所以一次调优的开始就是问你自己你想让应用多久发生一次GC？&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;线程池的大小&quot;&gt;线程池的大小&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;已经写过&lt;a href=&quot;https://www.reploop.org/blog/2020/05/how-to-size-thread-pool.html&quot;&gt;如何设置线程池的大小&lt;/a&gt;，可以移步过去看看。这里面主要考虑的是CPU的计算时间和等待时间这两个因素，就是找到合理的线程数来让你的应用的CPU使用情况能符合计算时间和等待时间这两个因素。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;对象池的大小&quot;&gt;对象池的大小&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;说到对象池，最常见的就是数据库的连接池了。因为他保持了真实的连接资源，那么连接池就不能任意的大，而且要根据请求的峰值来动态的扩容来满足性能指标，根据低谷数量来回收连接来释放资源。而且这两个过程要尽量保持平滑，从而避免给服务端比如数据库造成不好的影响。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;网络读超时read_timeout时间&quot;&gt;网络读超时（Read Timeout）时间&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;从开始读数据到读到第一个字节的最长时间，超过这个时间，客户端就会报一个Read timeout异常。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;quoteblock&quot;&gt; 
   &lt;blockquote&gt;
     Specifically, if the server fails to send a byte &amp;lt;timeout&amp;gt; seconds after the last byte, a read timeout error will be raised. 
   &lt;/blockquote&gt; 
   &lt;div class=&quot;attribution&quot;&gt;
     — Stephen C
    &lt;br&gt; &lt;cite&gt;http://stackoverflow.com/questions/3069382/what-is-the-difference-between-connection-and-read-timeout-for-sockets&lt;/cite&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这个和应用的处理模式有关系，可以考虑流式的处理，这样就可以尽可能早的开始返回数据。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;网络连接超时connection_timeout&quot;&gt;网络连接超时（Connection Timeout）&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这是建立TCP连接的三次握手完成时间。这里面的涉及的一个众所周知的速度，那就是光速。也就是网络传输速度的上限是信号在光纤中传输的速度-光速。根据 &lt;code&gt;距离=速度*时间&lt;/code&gt;，那么3次握手的网络连接时间至少是 &lt;strong&gt;3距离/速度(c=299792458m/s)&lt;/strong&gt;。那么从北京的机房连接到纽约的机房大约1万公里，那么网络连接时间至少是：&lt;code&gt;3 * 10000km / c = 100ms&lt;/code&gt;。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;请求超时request_timeout&quot;&gt;请求超时（Request Timeout）&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;上到应用层的请求，那么一次请求所需要的时间至少等于 Connection Timeout + Read Timeout + Data Transferring Time。 这里涉及请求本身的数据传输量，这部分时间也可以根据网速来计算出来。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;压缩阀值&quot;&gt;压缩阀值&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;数据该不该压缩也是进场要做的一个决策。这个决策就是压缩所花费的时间小于数据压缩后缩小部分的所需的传输时间，也就是收益大于成本。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这些场景工作中多多少少都有机会碰到，只要思路对上了，剩下的就是小学数学中的加减乘除就可以得出结论了。 这里面也提到了非常多的时间，这部分可以参考 &lt;a href=&quot;https://colin-scott.github.io/personal_website/research/interactive_latency.html&quot;&gt;Jeff Dean’s latency numbers&lt;/a&gt;。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;Jeff Dean’s latency numbers plotted over time - &lt;a href=&quot;https://colin-scott.github.io/personal_website/research/interactive_latency.html&quot; class=&quot;bare&quot;&gt;https://colin-scott.github.io/personal_website/research/interactive_latency.html&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>如何设置线程池的大小？</title>
                <link>https://www.reploop.org/blog/2020/05/how-to-size-thread-pool.html</link>
                <pubDate>Mon, 4 May 2020 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2020/05/how-to-size-thread-pool.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;多核环境下，为了更好的资源利用率，多线程基本上算是一个常规武器了。 我们知道CPU是用来计算的，而计算所需要的外部数据则是交给独立的I/O系统处理的。CPU和I/O的特点就是一个快，一个慢，大约差 &lt;a href=&quot;https://colin-scott.github.io/personal_website/research/interactive_latency.html&quot;&gt;2～3个数量级&lt;/a&gt;。所以为了不浪费快的资源，就把慢的事情交给独立的系统做，等慢的资源准备好了在通知快的资源(也叫 &lt;strong&gt;中断处理&lt;/strong&gt;)。所以一旦发生CPU需要等待外部数据的时候，操作系统的调度系统就会暂时保存当前计算的寄存器状态，程序计数器等(也叫 &lt;strong&gt;上下文&lt;/strong&gt;) ，让出CPU给其他的可调度的进程。 这个过程称为 &lt;strong&gt;上下文切换&lt;/strong&gt;。一旦发生了 &lt;strong&gt;上下文切换&lt;/strong&gt;，以 &lt;strong&gt;线程&lt;/strong&gt; 统一进行计算与I/O传输的应用这时就是被 &lt;strong&gt;阻塞&lt;/strong&gt; 了。为了提高CPU的利用率，应用层面就是使用多个线程来保证CPU有计算可执行，线程池就是这么产生了。 以下就是本文的核心问题，如果你要创建一个线程池，该怎么确定线程池的大小呢？可以肯定的是线程数也不是越多越好。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;线程池的大小&quot;&gt;线程池的大小&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;关于线程池的大小，有两本非常有名的书中都有相关的论述。这两本书还都是Java生态里面重量级人物写的。分别看一下：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;java_concurrency_in_practice&quot;&gt;Java Concurrency In Practice&lt;/h3&gt; 
   &lt;div class=&quot;quoteblock&quot;&gt; 
    &lt;blockquote&gt;
      For compute intensive tasks, an &lt;em&gt;N&lt;sub&gt;cpu&lt;/sub&gt;&lt;/em&gt;-processor system usually achieves optimum utilization with a thread pool of &lt;em&gt;N&lt;sub&gt;cpu&lt;/sub&gt;&lt;/em&gt;+1 threads. (Even compute intensive threads occasionally take a page fault or pause for some other reason, so an &quot;extra&quot; runnable thread prevents CPU cycles from going unused when this happens.) For tasks that also include I/O or other blocking operations, you want a larger pool, since not all of the threads will be schedulable at all times. In order to size the pool properly, you must estimate the ratio of waiting time to compute time for your tasks; this estimate need not be precise and can be obtained through profiling or instrumentation. Alternatively, the size of the thread pool can be tuned by running the application using several different pool sizes under a benchmark load and observing the level of CPU utilization. 
    &lt;/blockquote&gt; 
    &lt;div class=&quot;attribution&quot;&gt;
      — Brian Göetz
     &lt;br&gt; &lt;cite&gt;Java Concurrency In Practice: p.107&lt;/cite&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;书中先给出如下一些定义:&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;&lt;em&gt;N&lt;sub&gt;cpu&lt;/sub&gt;&lt;/em&gt; = CPU核心数,&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;&lt;em&gt;U&lt;sub&gt;cpu&lt;/sub&gt; = 目标CPU的使用率，其中 \$0 &amp;lt;=\$ _U&lt;sub&gt;cpu&lt;/sub&gt;&lt;/em&gt; \$&amp;lt;= 1\$,&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;\$w\$ = CPU等待时间，&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;\$c\$ = CPU计算时间，&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;\$w/c\$ = CPU等待时间和计算时间的比率,&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;然后就给出了能够使处理器保持在特定使用率的线程数最优公式： &lt;em&gt;N&lt;sub&gt;threads&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;N&lt;sub&gt;cpu&lt;/sub&gt;&lt;/em&gt; * &lt;em&gt;U&lt;sub&gt;cpu&lt;/sub&gt;&lt;/em&gt; * (\$1 + w/c\$)&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;programming_concurrency_on_the_jvm&quot;&gt;Programming Concurrency on the JVM&lt;/h3&gt; 
   &lt;div class=&quot;quoteblock&quot;&gt; 
    &lt;blockquote&gt;
      If tasks spend 50 percent of the time being blocked, then the number of threads should be twice the number of available cores. If they spend less time being blocked—that is, they’re computation intensive—then we should have fewer threads but no less than the number of cores. If they spend more time being blocked—that is, they’re IO intensive—then we should have more threads, specifically, several multiples of the number of cores. 
    &lt;/blockquote&gt; 
    &lt;div class=&quot;attribution&quot;&gt;
      — Venkat Subramaniam
     &lt;br&gt; &lt;cite&gt;Programming Concurrency on the JVM: p.16&lt;/cite&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;这本书里没有直接给出变量定义，而是用文字描述的。为了便于比较，这里也给出一些定义：&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;&lt;em&gt;N&lt;sub&gt;threads&lt;/sub&gt;&lt;/em&gt; = 总的线程数，&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;&lt;em&gt;N&lt;sub&gt;cpu&lt;/sub&gt;&lt;/em&gt; = 可用的CPU核心数，&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;&lt;em&gt;B&lt;sub&gt;c&lt;/sub&gt;&lt;/em&gt; = 阻塞系数，介于0和1之间的。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;那么，就可以用如下的方式计算我们需要的线程数了： &lt;em&gt;N&lt;sub&gt;threads&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;N&lt;sub&gt;cpu&lt;/sub&gt;&lt;/em&gt; / (1 - &lt;em&gt;B&lt;sub&gt;c&lt;/sub&gt;&lt;/em&gt;)&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;分析与结论&quot;&gt;分析与结论&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;乍一看，两本书给出了2个不一样的公式，该如何取舍呢？&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;假设CPU的使用率 &lt;em&gt;U&lt;sub&gt;cpu&lt;/sub&gt;&lt;/em&gt; 是100%的情况下，也就是如果目标都是尽可能的利用CPU资源，其实这两个公式是一样的。 只要定义阻塞系数(blocking coefficient) = \$w/(w+c)\$，也就是阻塞系数为阻塞时间与整个CPU时间的占比。那么他们就是一个意思：定性的描述就是阻塞时间越多，就需要更多线程来保证CPU有活干。上面2个不同的公式则是定量的表达上述思路了。优化线程池的大小是想用最少的线程上下文切换(或代价)来做到最大的(或特定目标)CPU使用率。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;第2本书没有把目标CPU使用率放到公式里面，都包含在阻塞系数里面了。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>码农工作中的缩写词</title>
                <link>https://www.reploop.org/blog/2020/05/dev-acronyms.html</link>
                <pubDate>Sat, 4 Apr 2020 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2020/05/dev-acronyms.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;码农工作中，如果经常看一些英文的文档，混迹于github上抄抄源代码，发发邮件交流的话，或者和早几年外企出来的人一起工作的话，可能经常能看到一些缩写词。不懂的人一脸懵逼，懂的人可能因为少打了几次键盘提高了效率而提前下班被领导白眼。 不过缩写词也就是习惯的问题，不是啥逼格的问题。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;常用缩写词&quot;&gt;常用缩写词&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;dlist&quot;&gt; 
   &lt;dl&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     RP
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;pull request, 两个不同的代码仓库之间的合并请求。在分布式源码管理系统出来之后才有的概念，就是让别人拉取代码仓库变化的意思。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     MR
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;merge request, 提交代码前的合并请求。为了控制代码质量，有些代码分支不允许直接提交。 MR一般发生在向一个受保护的分支提交代码并请求评审代码的意思。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     IMHO
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;In My Humble Opinion. 也就是以我之见，恕我直言的意思。一般情况下是用于提出不同意见的。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     TBD
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;to be done，未完待续。意思是说一项工作应该要做，但是还没有完成。好多开源项目的文档中经常会看到。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     WIP
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;work in process, 施工/设计/处理/工作中，指一项工作正在进行中，还没有完成。开源中的Pull Request如果特别大，要分多次合并的话，每个Pull Request都可以加上[WIP]，说明还有后续的合并请求。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     WTF
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;what the fuck，类似国骂&quot;我艹&quot;之类的，语气词，大概就是这是什么玩意的意思。代码注释中经常能看见WTF的身影，愤怒的程序员。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     FYI
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;for your information，供你参考。一般是想把一个信息同步给另一个人，请他知晓的意思。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     TL;DR
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;too long, don’t read，太长，别看，也就是长篇大论预警提示。一般是一个结论的详细说明，如果仅仅关注结论，不关心缘由的话可以直接跳过的。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     LGTM
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;looks good to me，看起来不错。代码评审中的同意的意思。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     PTAL
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;please take a look，请看一下我的提交。github上经常能看到，某个代码提交或者合并请求，需要某个人评审，就可以这么说。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     SGTM
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;sounds good to me，听起来不错。代码评审中的同意的意思，或者某项提议/设计方案不错的意思。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     RTFM
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;read the fucking manual, 先读一下手册。一般都是问题太简单，都写在手册里面了。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     STFW
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;search the fucking web, 先上网查一下。一般都是问题太简单，简单搜索就能找到答案。&lt;/p&gt; 
    &lt;/dd&gt; 
    &lt;dt class=&quot;hdlist1&quot;&gt;
     W/O
    &lt;/dt&gt; 
    &lt;dd&gt; 
     &lt;p&gt;without, 经常在github的issue中看到w/o，勉强也可也算开发术语，w/o转化为without之后就简单了吧？&lt;/p&gt; 
    &lt;/dd&gt; 
   &lt;/dl&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;暂时写这么多，后面遇到新的在补充。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>nginx配置文件中的location匹配规则</title>
                <link>https://www.reploop.org/blog/2020/04/nginx-location-matching-rules.html</link>
                <pubDate>Sat, 4 Apr 2020 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2020/04/nginx-location-matching-rules.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;在反向代理的场景下，nginx用的人很多。在使用nginx的过程中，除了常规的反向代理配置，还经常临时性的要封个请求，加个限速，跳转一下等是常有的事情。这些都和location的配置规则相关。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;location语法&quot;&gt;location语法&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;location支持5种语法，分别为：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;listingblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;pre&gt;1. location =   /uri {}   #完整字符串匹配，优先级最高，发现匹配就停止
2. location ^~  /uri {}   #字符串前缀匹配，发现匹配就停止。这个不是正则匹配
3. location     /uri {}   #字符串前缀匹配，取最具体的那个匹配（the most specific match），可理解为最长匹配。这里即使是找到了匹配，也会继续执行后面的正则匹配。
4. location ~   /uri {}   #正则匹配,大小写敏感。按在配置文件中定义的顺序执行，发现匹配就停止（The first regular expression to match the query will stop the search））
5. location ~*  /uri {}   #同规则4(~)，区别就是正则匹配时大小写不敏感&lt;/pre&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;“发现匹配就停止”的意思是匹配过程终止了，已经得到了匹配结果并提前返回了，不会在执行后面的匹配了。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;执行顺序&quot;&gt;执行顺序&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;执行完整字符串匹配。从1)开始搜索，如果1）找到匹配，则停止搜索；&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;执行字符串前缀匹配。执行2），3），目的是找到最具体的那个匹配。此过程不会停止整个匹配过程，完成后会继续执行正则匹配。唯一的例外是，如果location的操作是^~，只要发现匹配就停止搜索；&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;执行正则匹配。4），5），按照配置文件中出现的顺序挨个匹配，如果发现匹配则停止搜索；&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;相同规则内执行顺序是按照规则在配置文件中出现的顺序从上到下顺序执行的。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;一句话概括一下就是先执行完整字符串匹配，找到匹配就结束，没有找到匹配，就继续执行前缀和正则匹配，最后就是如果找到正则匹配，就用正则匹配结果，如果没有找到，就用前缀匹配的结果。当然，有一个例外。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;匹配结果&quot;&gt;匹配结果&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;根据 &lt;strong&gt;执行顺序&lt;/strong&gt; 节的解释，我们可以确定匹配结果的优先级是：&lt;strong&gt;完整字符串匹配&lt;/strong&gt; &amp;gt; &lt;strong&gt;^~前缀匹配&lt;/strong&gt; &amp;gt; &lt;strong&gt;正则匹配&lt;/strong&gt; &amp;gt; &lt;strong&gt;字符串前缀匹配&lt;/strong&gt;。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;location优化建议&quot;&gt;location优化建议&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;根据不同匹配的不同规则，&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;在确定的情况下优先使用完整字符串匹配（=），&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;接下来优先使用（^~）。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;接下来就是正则匹配的location要合理排序，最常用，访问最多的要排到前面。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;最后是少写不带操作符的字符串前缀匹配。也就是location语法中的3.原因是a)这个过程是在正则匹配之前执行的，为了找到最具体的匹配，应该是需要全部执行;b)它的结果优先级没有正则匹配的高，如果后来发现了正则匹配，此过程就没有意义了。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;同时应该注意的是正则匹配（4，5）是按照配置文件中出现的顺序挨个匹配，取第一个匹配的结果。如果顺序安排不当，会有覆盖的结果。比如：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;listingblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;location ~ /uri {}           &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
location ~ /uri/\d{1,}/ {}   &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这个配置文件，如果遇到 &lt;strong&gt;/uri/12345/&lt;/strong&gt; 这个请求的时候，最后的匹配结果是uri &amp;lt;1&amp;gt;，而不是后者 &amp;lt;2&amp;gt;。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;nginx.org - &lt;a href=&quot;http://wiki.nginx.org/HttpCoreModule#location&quot; class=&quot;bare&quot;&gt;http://wiki.nginx.org/HttpCoreModule#location&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>HTTPS如何工作的？</title>
                <link>https://www.reploop.org/blog/2020/03/how-https-works.html</link>
                <pubDate>Sat, 28 Mar 2020 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2020/03/how-https-works.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;如今的HTTPS基本上已经占据了大部分流量,根据 &lt;a href=&quot;https://transparencyreport.google.com/https/overview?hl=en&quot;&gt;Google Chrome的统计&lt;/a&gt;，截止2020年3月21日，有 &lt;strong&gt;96%&lt;/strong&gt; 的请求是走HTTPS的。以Chrome浏览器的市场占有率，应该很能说明问题了。嗯，HTTPS在大部分场景下基本上是标配了。那弄懂HTTPS的工作机制就很有必要了。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2020/03/images/https-by-chrome.png&quot; alt=&quot;HTTPS Encryption by Chrome platform&quot;&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;从http到https&quot;&gt;从HTTP到HTTPS&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。而HTTPS则可以称为安全版本的HTTP， HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;网站服务器身份认证&quot;&gt;网站服务器身份认证&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;拿Facebook作为例子，当我们在浏览器地址栏输入http://www.facebook.com之后，我们怎么能确定访问的就是Facebook的网站呢? 大部分情况下应该是的，但是也有些钓鱼网站，DNS污染等等手段是能让我们访问到别有用心的其他网站。也就是说不管怎么样，我们不能100%的确信。为了能够确定我们访问的是真正的Facebook，我们是需要一种方法来确认服务器是Facebook的而不是其他网站的，也就是服务器的身份认证。如果能做到这个，我们就能判断出是否访问了攻击者仿冒的网站而不是真正的Facebook。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;幸运的是，使用非对称加密我们是可以做到的。具体就是Facebook需要有一对公钥和私钥，然后公布自己的公钥，但是把私钥安全保存在自己的服务器上。现在，你只要用Facebook的公钥加密自己的请求数据，根据加密知识，你知道只有Facebook的私钥才能解密这个数据。如果你访问的服务器能够正确的解密数据并且给你返回数据，你就能确信服务器有Facebook的私钥。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;只要Facebook能够保护好自己的私钥，确保不被其他人盗用，我们就解决了服务器的认证问题，简单。这样的话，尽管受到互联网本身特性的制约，我们还是设计了一种方法来验证网站的身份。事实上，我们刚刚描述的这个过程和真正的HTTPS是非常像的。当我们说一个服务器的HTTPS证书的时候，我们其实说的就是一个公钥。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;尽管如此，上述过程存在一个大问题，而这个问题HTTPS必须要解决的。这个问题就是你如何获取每个你想访问的网站的公钥呢？当然了，你有了Facebook的公钥就可以安全的访问Facebook了，但是，如果你想安全的访问Google，你需要Google的公钥。同样的，你想安全的访问Twitter，你需要Twitter的公钥。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;互联网上有成千上万的网站，而且还在不停的变化。所以就不太可能在你的个人电脑上保存一份全部网站的公钥，只能换一种思路了。现在，我们可以不用在电脑上一直维护这个巨大的公钥列表，而是在第一次访问网站的时候让网站发给我们她的公钥。不过这样就又回到开始的问题了：如果我们在不知情的情况下访问了恶意的第三方，那第三方可能会伪装并且发送她自己的公钥给我们。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;到这一步，你可能要泄气了。虽然我们使用了公钥和私钥，但是我们实际上又回到了最初的问题：我们需要一种让Facebook能够证明其身份的方法，然后我们才能信任他们的公钥。既然如此，公钥的真正的意义又是啥呢？&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;证书和证书颁发机构&quot;&gt;证书和证书颁发机构&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;还有一个问题是互联网上的某个网站不能对每个访问者验证其公钥的有效性，因为现今互联网的规模大到这么做是不经济的。想象一下Facebook &lt;a href=&quot;https://www.statista.com/statistics/490424/number-of-worldwide-facebook-users/&quot;&gt;16.9亿&lt;/a&gt;用户，每个用户至少得发起一次请求，鉴于HTTP的无状态特性，每次请求都要验证一下这个公钥的有效性，这个规模是非常大的。为了解决这个问题，我们使用证书机构或者简称CA。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;证书机构(CA)能正确工作的前提是我们首先得信任他。这听起来有很多顾虑，但是实践中却工作的很好。CA是依靠信任的，所以当CA做了一些可疑的事情，浏览器马上就不再信任这些CA，这些CA也就该倒闭了。即使是CA方面的简单错误也足以永久破坏其声誉。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;那CA是如何解决我们的身份认证问题的呢？CA收钱为网站提供这种身份认证服务。DigiCert是一家有名的CA，同时也是Facebook使用的CA，我们就用她作为CA的例子。Facebook想证明她的公钥的有效身份，从而让用户安全的访问。所以她就花钱请DigiCert确认她就是真正的Facebook，一旦做了这个，DigiCert就会知道哪个公钥真的就是Facebook的。现在当你访问Facebook的时候，你就不需要Facebook证明她自己的身份了，你只需要Facebook证明DigiCert已经验证过她的身份就可以了。DigiCert为许多网站提供这种服务，你不需要弄清楚如何信任某个网站，你只需要信任DigiCert就可以了。如果你信任DigiCert，而DigiCert信任Facebook，那么理论上你就可以信任Facebook了。我们叫这个信任链。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;从抽象的高度看，这就是HTTPS的工作原理了。但是，我们需要弄清楚该过程的中的两个具体细节，才能理解详细的工作原理。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;ulist&quot;&gt; 
    &lt;ul&gt; 
     &lt;li&gt; &lt;p&gt;你怎么知道你正在使用DigiCert，而不是仿冒的DigiCert？&lt;/p&gt; &lt;/li&gt; 
    &lt;/ul&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;这看起来又回到问题的起点了。如果我们拥有DigiCert的公钥，则可以验证其身份。但是我们需要以某种方式确保我们拥有DigiCert的公钥，而不是别人的。这里的解决办法是什么呢？其实是我们使用的操作系统或浏览器已经存储了DigiCert的公钥。现如今，我们信任很多CA，只不过她们是众所周知的，才能让现代操作系统或者浏览器存储她们的公钥。这部分公钥存储在计算机的“受信任的根证书颁发机构存储区(Trusted Root Certificate Authority Store)”中。存储的密钥数量似乎很多，但这总比为互联网上的每个网站存储一个公钥要容易多了。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;ulist&quot;&gt; 
    &lt;ul&gt; 
     &lt;li&gt; &lt;p&gt;Facebook如何证明DigiCert对其进行了验证？&lt;/p&gt; &lt;/li&gt; 
    &lt;/ul&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;一旦DigiCert验证过Facebook就是Facebook之后，DigiCert就知道了Facebook的真正公钥，然后使用自己的私钥对Facebook的公钥进行数字签名，并且将这个签名后的公钥给Facebook。这种交互完全发生在Facebook和DigiCert之间，而且远远早于用户连接到Facebook的时间，一般网站上线之前就发生了。现在，当你连接到Facebook时，Facebook会给你发送一个已由DigiCert的私钥签名的公钥。然后你可以使用操作系统存储的公钥来验证DigiCert对Facebook的公钥进行了签名。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;整个过程中有两对公钥和私钥，一对是网站的，一对是CA的。双方都对外公布自己的公钥，并安全保存自己的私钥。网站的公钥先是给了CA，被签名之后间接的最终还是给了用户，这个公钥在协商阶段还会用到。而CA的公钥则直接被操作系统或者浏览器存储下来了，也相当于给了用户。CA用自己的私钥对网站的公钥进行数字签名，发给网站，这就是服务器的证书。当用户连接到服务器的握手环节，服务器发送证书给用户，用户通过本地的CA的公钥来解密网站发来的证书(CA私钥签名过的网站公钥)，如果成功则完成了验证问题。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;保护交换数据的隐私与完整性&quot;&gt;保护交换数据的隐私与完整性&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;使用非对称加密完成了网站服务器的身份认证，接下来的保护交换数据的隐私与完整性则最终使用了对称加密手段。过程非常复杂，HTTPS的握手环节还进了用户与服务器之间一系列的加密算法，对称加密密码等等协商之后就可以进行安全的访问了。HTTPS完整的握手环节可以通过 &lt;a href=&quot;https://tls13.ulfheim.net/&quot;&gt;这里&lt;/a&gt;查看，详细到每个字节，同时也解释了协议并且图形化描述了整个过程。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;olist arabic&quot;&gt; 
   &lt;ol class=&quot;arabic&quot;&gt; 
    &lt;li&gt; &lt;p&gt;Google Transparency Report - &lt;a href=&quot;https://transparencyreport.google.com/https/overview?hl=en&quot;&gt;HTTPS encryption on the web&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;www.youdzone.com - &lt;a href=&quot;http://www.youdzone.com/signature.html&quot;&gt;What is a Digital Signature?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;ulfheim.net - &lt;a href=&quot;https://tls13.ulfheim.net/&quot;&gt;The New Illustrated TLS Connection&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;dnsimple.com - &lt;a href=&quot;https://support.dnsimple.com/articles/what-is-ssl-certificate-chain/&quot;&gt;What is the SSL Certificate Chain?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;/ol&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>理解内存重排序以及为什写无锁多线程代码时很重要</title>
                <link>https://www.reploop.org/blog/2020/02/understanding-memory-reordering.html</link>
                <pubDate>Sat, 29 Feb 2020 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2020/02/understanding-memory-reordering.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;此系列前一篇文章中，&lt;a href=&quot;https://www.reploop.org/blog/2020/02/lock-free-multithreading-with-atomic-operations.html&quot;&gt;用原子操作实现无锁多线程&lt;/a&gt;，我介绍了无锁多线程：并发软件中线程同步的底层机制。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;基于 &lt;strong&gt;原子操作&lt;/strong&gt;，也就是CPU直接执行的不能细分为更小步骤的机器指令，相比传统的同步原语如&lt;a href=&quot;https://www.reploop.org/blog/2020/02/introduction-to-thread-synchronization.html&quot;&gt;互斥锁和信号量&lt;/a&gt;，无锁多线程提供了更快和更细粒度控制的同步机制。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;一如既往的，能力越大，责任越大。无锁编码中你更接近本质，因此理解机器是如何工作的以及机器的特性是非常有益的。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;本文中我会介绍一些硬件（和软件）对无锁代码产生的非常重要的副作用。这也是惊叹计算机内部小型世界的复杂性的机会。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;div class=&quot;title&quot;&gt;
    本系列中的其他文章
   &lt;/div&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;&lt;a href=&quot;https://www.reploop.org/blog/2020/02/a-gentle-introduction-to-multithreading.html&quot;&gt;多线程简介&lt;/a&gt; - 一步一步走进并发的世界&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;a href=&quot;https://www.reploop.org/blog/2020/02/introduction-to-thread-synchronization.html&quot;&gt;线程同步简介&lt;/a&gt; - 多线程应用中最常见的并发控制方法之一&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;a href=&quot;https://www.reploop.org/blog/2020/02/lock-free-multithreading-with-atomic-operations.html&quot;&gt;用原子操作实现无锁多线程&lt;/a&gt; - 底层线程同步&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;内存重排序或者不愉快的惊喜&quot;&gt;内存重排序或者不愉快的惊喜&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;现有编程课程首先要教你的是计算机如何 &lt;strong&gt;顺序&lt;/strong&gt; 执行用源代码写出的指令。一段程序就是文本文件中的一系列操作，处理器会从上到下执行这些操作。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;意外的，这常常是一个谎言：你的机器有能力按需调整 &lt;em&gt;一些&lt;/em&gt; 底层指令的执行顺序，尤其是内存读取的时候。这个诡异的修改，叫做 &lt;strong&gt;内存重排序&lt;/strong&gt;，会发生在硬件和软件层面，且经常是因为性能的原因。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;内存重排序开发出来旨在利用那些原本要浪费掉的指令周期。这个技巧能大幅度提升你程序的执行速度；另一方面，它可能对无锁多线程造成严重破坏。我们马上能看到为啥。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;我们先来仔细看一下内存重排序这种不可预知的行为存在的原因。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;内存重排序总结&quot;&gt;内存重排序总结&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;程序想要执行，必须加载进 &lt;strong&gt;主内存&lt;/strong&gt;。CPU的任务就是执行存储在那的指令，同时在必要的时候读数据或者写数据。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;随着时间的推移，这种类型的内存和处理器比起来变得非常慢。例如，一个现代的CPU一个纳秒内能够执行10个指令，但是需要纳秒的许多倍时间从主内存中读取数据！工程师们不喜欢时间就这样浪费了，所以他们给CPU配上了容量很小但是速度非常快的特殊内存，我们称之为 &lt;strong&gt;缓存&lt;/strong&gt;。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;缓存是为了避免和慢速主内存交互，用来存储CPU最常用的数据的。如果CPU需要从主内存读取或者写入主内存，它首先检测缓存看是不是有所需数据的副本。如果有，处理器就直接从缓存读取或者写入缓存而不会等待相比较慢的主内存的响应。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;现代CPU有多个核心组成的，&lt;strong&gt;核心(core)&lt;/strong&gt; 是真正执行计算的组件。每个核心拥有自己的独立缓存，如下图所示：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2020/02/images/cpu-cache-main-memory.png&quot; alt=&quot;CPU&quot; width=&quot;cache and main memory&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 1. 多个核心通过缓存和主内存交互的简化模型。这也叫做共享内存系统，因为主内存被多个实体访问。
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;总而言之，缓存能让计算机运行更快。更准确的说，缓存通过让处理器总是繁忙和高效来帮助处理器不要因为等待主内存响应而浪费宝贵的时间。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;内存重排序作为优化技巧&quot;&gt;内存重排序作为优化技巧&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;很明显缓存机制增加了多核场景下系统的复杂性。现在你需要详细的规则来决定数据如何在不同的缓存间流动，来保证每个核心有最新版本的数据，称之为 &lt;strong&gt;缓存一致性协议&lt;/strong&gt;，他可能引发非常大的性能下降。所以工程师们就设想用内存重排序来充分发挥每个核心的作用。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;内存重排序为什么会发生的理由有很多个。比如，考虑2个核心同时访问同样的内存块。核心A从内存读取数据，核心B写入数据到内存。内存一致性协议可能会强制核心A等待核心B将本地修改的数据写回到主内存，这样核心A就能读到最新的数据。这个等待的核心可以选择提前执行其他内存指令，而不是浪费珍贵的指令周期啥也不做，即使这个和你在程序中明确的代码顺序不一样。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;当特定的优化开启了，编译器和虚拟机也会启用重排序指令。这些变化发生在编译时，可以通过汇编码或者字节码很容易的看到。软件内存重排序是充分利用底层硬件可能提供的特性来让你的代码运行的更快。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;硬件内存重排序的具体样例&quot;&gt;硬件内存重排序的具体样例&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;考虑下面用硬件伪代码写的样例。程序的每一个步骤都对应一个处理器指令：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;listingblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;x = 0
v = false

thread_one():
    while load(v) == false:
        continue
    print(load(x))

thread_two():
    store(x, 1)
    store(v, true)&lt;/code&gt;&lt;/pre&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;上面的代码片段中2个线程并发运行在2个不同的核心上。第1个线程等待第2个线程将 &lt;code&gt;v&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt;。让我们假设 &lt;code&gt;store()&lt;/code&gt; 和 &lt;code&gt;load()&lt;/code&gt; 都是读取内存的原子CPU指令。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;你预计第1个线程在屏幕上打印出什么？如果他在线程2之前启动（ &lt;a href=&quot;https://internalpointers.com/post/gentle-introduction-multithreading#race-conditions&quot;&gt;并不总是这样的&lt;/a&gt;），就没有正确的答案了。如果没有重排序发生，你可能会看到1。尽管如此，如果第2个线程中的存储指令发生重排序，&lt;code&gt;v&lt;/code&gt; 的更新也可能发生在 &lt;code&gt;x&lt;/code&gt; 之前，打印语句可能打印出 &lt;code&gt;0&lt;/code&gt;。相似的，内存重排序也可能发生在第1个线程中，也就是 &lt;code&gt;x&lt;/code&gt; 的加载可能发生在 &lt;code&gt;v&lt;/code&gt; 的检测之前。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;内存重排序对多线程的影响&quot;&gt;内存重排序对多线程的影响&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;硬件内存重排序在单核计算机上没有问题，因为线程是操作系统控制的软件结构。CPU就是收到连续的内存指令流。指令还是可以被重新排序，不过要符合一个基本规则：给定内核的内存访问看上去就像和代码写的一样。所以，内存重排序可能会发生，但是只在不影响最终结果的前提下。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这个规则也适用于多核场景下的每个单核，但不适用于不同操作同时跑在独立的硬件上的情况（ &lt;a href=&quot;https://internalpointers.com/post/gentle-introduction-multithreading#what-threads-are-used-for&quot;&gt;真并行(true parallelism)&lt;/a&gt;）。让你的线程跑在两个物理内核上，你就会碰到上面样例中的各种诡异问题，更不用说让编译器和虚拟机执行重排序了。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;常规的如互斥锁和信号量等&lt;a href=&quot;https://www.reploop.org/blog/2020/02/introduction-to-thread-synchronization.html&quot;&gt;锁同步机制&lt;/a&gt;是设计用来处理硬件和软件层面的内存重排序的。毕竟他们是上层技术。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;不过，应用无锁方案的多线程程序更接近底层：就像&lt;a href=&quot;https://www.reploop.org/blog/2020/02/lock-free-multithreading-with-atomic-operations.html&quot;&gt;上一篇文章&lt;/a&gt;看到的，它利用存储和加载原子指令来同步线程。 搞笑的是这些操作可能被重排序，从而破坏了你的严谨计划。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;如何解决内存重排序的问题&quot;&gt;如何解决内存重排序的问题&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;你肯定不会基于一些随机变化的东西构建你的同步机制。这个问题可以通过引入 &lt;strong&gt;内存屏障&lt;/strong&gt; 的方式来解决。内存屏障是强制处理器按照可预知的方式访问内存的CPU指令。内存屏障的工作方式类似路障：内存屏障之前的指令保证先于内存屏障之后的指令执行。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;内存屏障是硬件层面的：你得直接和CPU交互。这是一个底层的解决方案，且不利于程序的可移植性。解决这个问题最好的方式是软件层次，利用操作系统，编译器或虚拟机提供的工具。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;尽管如此，软件工具也仅仅是中间阶段。为了构建一个此问题的清晰的全景图，我们首先全局看一下所有可能在硬件或者软件系统中的内存场景。&lt;strong&gt;内存模型&lt;/strong&gt; 在这个过程中发挥重要作用。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;内存模型&quot;&gt;内存模型&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;内存模型是抽象的方式描述系统中涉及到访问和重排序内存可能或者不可能发生的事情。处理器和编程语言会实现一个，尤其是利用多线程技术的时候：内存模型同时适用于硬件和软件层面。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;当系统对改变内存操作顺序非常谨慎，我们说系统遵循 &lt;strong&gt;强内存模型&lt;/strong&gt;。相反的，&lt;strong&gt;弱内存模型&lt;/strong&gt; 中你可能碰到各种各样的重排序。比如，x86系列的处理器属于前一类，而ARM和PowerPC处理器则属于后一类。软件层面又是怎么样的呢？&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;软件内存模型的好处&quot;&gt;软件内存模型的好处&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;硬件内存模型存在的原因很明显，而对应的软件内存模型让你能够按需重排内存访问顺序。这个特性在你写无锁多线程代码的代码能帮很大的忙。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;例如，为了避免同步机制中不受欢迎的原子操作的重排序，编译器可以编译出遵循强内存模型的机器码。当底层硬件实现的是弱内存模型的时候，编译器会通过加入正确的内存屏障指令来最大限度的提供你需要的内存模型。编译器也负责软件层面的内存重排序指令。使用软件内存模型可以解耦硬件细节。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;基本上，所有的编程语言都会实现一种内存模型，某种意义上说，他们都遵循特定的规则来处理内存。一些编程语言也就到此为止了，因为他们不直接处理多线程。其他的比如 &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/VarHandle.html&quot;&gt;Java&lt;/a&gt;， &lt;a href=&quot;https://doc.rust-lang.org/nomicon/atomics.html&quot;&gt;Rust&lt;/a&gt;和 &lt;a href=&quot;https://en.cppreference.com/w/cpp/atomic/memory_order&quot;&gt;C++&lt;/a&gt;等也会提供上述的控制内存重排序行为的工具。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;细粒度内存模型&quot;&gt;细粒度内存模型&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;强和弱内存模型是对内存操作如何重排序的理论上的分类。具体到真实的编码，大多数支持原子操作的编程语言会提供3种控制内存重排序的方式。我们仔细看一下。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;1顺序一致&quot;&gt;1）顺序一致&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;较少干扰的内存重排序方式就是根本不重排序。这是强内存模型的一种形式，称之为顺序一致：这正是解决上面提到的所有无锁多线程问题所需要的。禁用重排序能让你的多线程程序容易理解：源代码是按照书写顺序执行的。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;顺序一致给并行代码执行加了另外一个重要特性：它强制了所有线程中的所有内存原子操作的 &lt;strong&gt;整体顺序&lt;/strong&gt;。为了更好理解这句话，考虑如下的硬件伪代码样例：&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;listingblock&quot;&gt; 
    &lt;div class=&quot;content&quot;&gt; 
     &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;x = 0
y = 0

thread_A:
    store(x, 1)

thread_B:
    store(y, 1)

thread_C:
    assert(load(x) == 1 &amp;amp;&amp;amp; load(y) == 0)

thread_D:
    assert(load(x) == 0 &amp;amp;&amp;amp; load(y) == 1)&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;我们暂时不考虑单个线程内的内存重排序，看一下全局情况。如果线程按照A-C-B-D的顺序运行，线程C能看到 &lt;code&gt;x == 1&lt;/code&gt; 和 &lt;code&gt;y == 0&lt;/code&gt;，这是因为线程C是在线程A和线程B之间运行的，因此线程C的断言不会失败。但是这也是问题所在：顺序一致强加的全局顺序迫使线程D看到与线程C一样的事件，因此线程D的断言会失败。线程D不可能看到和线程C不一样的存储顺序。换句话说，线性一致下，所有的线程都看到同样的东西。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;就像前面说过的，这是一个非常直观和自然的思考多线程执行的方式。尽管如此，顺序一致也取消了内存重排序带来的任何硬件或者软件优化：这通常会引起严重性能瓶颈。顺序一致有些时候是必要的，比如多生产者-多消费者情况下消费者必须按照生产者的生产顺序消费。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;2获取_释放顺序&quot;&gt;2）获取-释放顺序&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;&lt;strong&gt;获取-释放&lt;/strong&gt; 是强和弱内存模型的中间状态。首先，获取-释放和顺序一致工作方式相似，除了没有全局执行顺序。我们在看一下上面的那个例子：在获取-释放情况下，线程D是允许看到不同于线程C的事件，因此线程D的断言有可能会通过。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;全局顺序的缺失其实是个副作用。获取-释放是针对 &lt;em&gt;特定&lt;/em&gt; 共享原子变量在 &lt;em&gt;多个线程之间&lt;/em&gt; 同步的。也就是说，你在线程A和线程C之间同步共享变量 &lt;code&gt;x&lt;/code&gt;，使得线程C只能在线程A完成写入之后才读取。这种情况下，&lt;code&gt;y&lt;/code&gt; 并没有考虑进去，所以你可碰到任何针对它的重排序。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;具体来说，支持这种有序性的编程语言允许你将内存访问标记为获取或者释放。当线程B触发某共享变量上标记为获取的原子加载操作，线程A中的同一个共享变量上标记为释放的原子存储可确保线程B将看到线程A执行的完整且不是重新排序的内存事件序列。我知道这比较烧脑，不过这是互斥锁的基础：关键区和它保护的区域就是用这个构建的（获取-释放名字来源于互斥锁术语，也就是获取和释放互斥锁）。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;获取-释放允许更多的优化机会，因为仅有部分内存重排序不被允许。换句话说，你的程序更不容易推理分析了。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;3松散顺序&quot;&gt;3）松散顺序&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;还有一种弱内存模型的形式。&lt;strong&gt;松散顺序&lt;/strong&gt; 的情况下，你写程序的时候根本不关心内存重排序。编译器和处理器可以尽可能的优化程序执行。当然了内存操作的原子特性是保留下来了：这在增加共享计数器的时候非常有用，这种情况下操作必须是原子的才能让其他线程不能看到未完成的中间状态。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;松散有序性不保证任何特定的内存重排序，所以这不是可以安全使用的线程同步工具。另一方面，这也允许使用任何内存技巧来提升你的多线程程序的性能。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;下一步&quot;&gt;下一步？&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这篇文章中，我想对内存重排序问题以及其存在的原因和它对无锁多线程的影响有一个全面的了解。接下来我会写一些使用原子操作的C++代码来实践一下。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;为什么是C++ ？因为C++语言近期引入了 &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/memormodel&quot;&gt;非常详细的内存模型&lt;/a&gt;，使得你能够细粒度的控制C++原子对象的内存重排序操作。我相信这是一个很好的方式去看顺序一致，获取-释放和松散有序在真实的场景下是如何一起工作的。祝我好运吧:)。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;AA.VV. - &lt;a href=&quot;https://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016&quot;&gt;A Primer on Memory Consistency and Cache Coherence&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;AA. VV. - &lt;a href=&quot;https://books.google.it/books?id=MMNiDwAAQBAJ&quot;&gt;C++ Reactive Programming&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Paul E. McKenney - &lt;a href=&quot;http://www.puppetmastertrading.com/images/hwViewForSwHackers.pdf&quot;&gt;Memory Barriers: a Hardware View for Software Hackers&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;cppreference.com - &lt;a href=&quot;https://en.cppreference.com/w/cpp/atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;GCC Wiki - &lt;a href=&quot;https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync&quot;&gt;Memory model synchronization modes&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;doc.rust-lang.org - &lt;a href=&quot;https://doc.rust-lang.org/nomicon/atomics.html&quot;&gt;Atomics&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Herb Sutter - &lt;a href=&quot;https://youtu.be/A8eCGOqgvH4?t=3419&quot;&gt;Atomic Weapons 1 of 2&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;The ryg blog - &lt;a href=&quot;https://fgiesen.wordpress.com/2014/07/07/cache-coherency/&quot;&gt;Cache coherency primer&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;The ryg blog - &lt;a href=&quot;https://fgiesen.wordpress.com/2014/08/18/atomics-and-contention/&quot;&gt;Atomic operations and contention&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Bartosz Milewski - &lt;a href=&quot;https://bartoszmilewski.com/2008/12/01/c-atomics-and-memory-ordering/&quot;&gt;C++ atomics and memory ordering&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Bartosz Milewski - &lt;a href=&quot;https://bartoszmilewski.com/2008/11/11/who-ordered-sequential-consistency/&quot;&gt;Who ordered sequential consistency?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;StackOverflow - &lt;a href=&quot;https://stackoverflow.com/questions/30958375/memory-barriers-force-cache-coherency&quot;&gt;Memory barriers force cache coherency?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;StackOverflow - &lt;a href=&quot;https://stackoverflow.com/questions/25345440/how-does-the-cache-coherency-protocol-enforce-atomicity&quot;&gt;How does the cache coherency protocol enforce atomicity?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;StackOverflow - &lt;a href=&quot;https://stackoverflow.com/questions/42746793/does-a-memory-barrier-ensure-that-the-cache-coherence-has-been-completed&quot;&gt;Does a memory barrier ensure that the cache coherence has been completed?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;StackOverflow - &lt;a href=&quot;https://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g&quot;&gt;C11 introduced a standardized memory model. What does it mean? And how is it going to affect C programming?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;StackOverflow - &lt;a href=&quot;https://stackoverflow.com/questions/12340773/how-do-memory-order-seq-cst-and-memory-order-acq-rel-differ&quot;&gt;How do memory_order_seq_cst and memory_order_acq_rel differ?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;StackOverflow - &lt;a href=&quot;https://stackoverflow.com/questions/12346487/what-do-each-memory-order-mean&quot;&gt;What do each memory_order mean?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Just Software Solutions - &lt;a href=&quot;https://www.justsoftwaresolutions.co.uk/threading/memory_models_and_synchronization.html&quot;&gt;Memory Models and Synchronization&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/CPU_cache&quot;&gt;CPU cache&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_coherence&quot;&gt;Cache coherence&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_barrier&quot;&gt;Memory barrier&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_ordering&quot;&gt;Memory ordering&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;James Bornholt - &lt;a href=&quot;https://www.cs.utexas.edu/~bornholt/post/memory-models.html&quot;&gt;Memory Consistency Models: A Tutorial&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Preshing on Programming - &lt;a href=&quot;https://preshing.com/20120625/memory-ordering-at-compile-time/&quot;&gt;Memory Ordering at Compile Time&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Preshing on Programming - &lt;a href=&quot;https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/&quot;&gt;Memory Barriers Are Like Source Control Operations&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Linux Journal - &lt;a href=&quot;https://www.linuxjournal.com/article/8211&quot;&gt;Memory Ordering in Modern Microprocessors, Part I&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Doug Lea - &lt;a href=&quot;http://gee.cs.oswego.edu/dl/html/j9mm.html&quot;&gt;Using JDK 9 Memory Order Modes&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;本文译自https://www.internalpointers.com/post/understanding-memory-ordering，英文读者可直接阅读原文。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>用原子操作实现无锁多线程：底层线程同步</title>
                <link>https://www.reploop.org/blog/2020/02/lock-free-multithreading-with-atomic-operations.html</link>
                <pubDate>Thu, 27 Feb 2020 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2020/02/lock-free-multithreading-with-atomic-operations.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;本文英文版经 &lt;a href=&quot;https://it.linkedin.com/in/federicarinaldi&quot;&gt;Federica Rinaldi&lt;/a&gt;仔细审阅过，谢谢。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;&quot;atom&quot;在希腊语中拾不可再分割的意思。在计算机中一个任务被称为原子的是指他不能再细分了：它不能再拆分为更小的执行步骤了。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;&lt;em&gt;原子性&lt;/em&gt; 是多线程操作的一个重要特征：因为原子操作是不可在细分的，所以一个线程是不可能干扰另一个正在并发执行原子操作的线程的。例如，当一个线程原子写入共享数据，其他线程是没有办法读取到未完成的数据。相反的，当一个线程原子读取共享数据，这个数据就像是单个时间点上的数据。换句话说，就是没有&lt;a href=&quot;https://www.reploop.org/blog/2020/02/a-gentle-introduction-to-multithreading.html&quot;&gt;数据竞争&lt;/a&gt;的风险。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;div class=&quot;title&quot;&gt;
    本系列中的其他文章
   &lt;/div&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;&lt;a href=&quot;https://www.reploop.org/blog/2020/02/a-gentle-introduction-to-multithreading.html&quot;&gt;多线程简介&lt;/a&gt; - 一步一步走进并发的世界&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;a href=&quot;https://www.reploop.org/blog/2020/02/introduction-to-thread-synchronization.html&quot;&gt;线程同步简介&lt;/a&gt; - 多线程应用中最常见的并发控制方法之一&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;a href=&quot;https://www.reploop.org/blog/2020/02/understanding-memory-reordering.html&quot;&gt;理解内存重排序&lt;/a&gt; - 为什写无锁多线程代码时它很重要&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;在&lt;a href=&quot;https://www.reploop.org/blog/2020/02/introduction-to-thread-synchronization.html&quot;&gt;上一篇文章&lt;/a&gt;中，我介绍了所谓的 &lt;strong&gt;同步原语&lt;/strong&gt;，也就是最常用的线程同步工具。他们是用来为多线程间处理共享数据的操作提供原子性的。怎么做到的呢？其实就是直接让单个线程执行并发任务，同时操作系统阻塞了其他线程直到第一个线程完成它的工作。这么做的原因是一个被阻塞的线程对其他线程是无害的。考虑到阻塞线程的能力，同步原语也称为 &lt;strong&gt;阻塞机制&lt;/strong&gt;。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;上一篇文章中的任意一种阻塞机制对大多数应用来说能够很好的工作。如果能够正确的使用，他们也是快速的和可靠的。尽管如此，他们还是有一些你可能需要考虑的缺点：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;olist arabic&quot;&gt; 
   &lt;ol class=&quot;arabic&quot;&gt; 
    &lt;li&gt; &lt;p&gt;他们会阻塞其他线程 - 休眠的线程什么也不做，单纯的等待唤醒信号：这可能会浪费宝贵的时间；&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;他们会卡死你的应用 - 如果一个持有同步原语锁的线程不管什么原因崩溃了，这个锁就永远不会释放了，等待这个锁的线程就永远卡住了；&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;你对休眠哪个线程没什么控制 - 通常是操作系统选择阻塞哪个线程。这会引发一个被称之为 &lt;strong&gt;优先级反转&lt;/strong&gt; 的不幸结果： 一个执行非常重要任务的高优先级线程被一个低优先级线程阻塞了。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ol&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;大多数时候你不会关注这些问题，因为他们不影响你应用程序的正确性。另一方面，有时候使线程一直运行是有必要的，特别是你想发挥多处理器/多核硬件的能力，或者你就是不能容忍系统被一个崩溃的线程拖死，或者优先级反转的问题是不容忽视的。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;无锁编程来救场&quot;&gt;无锁编程来救场&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;好消息：还有另一种控制多线程应用中并发任务的方法，为了避免上面提到的1）,2）和3）点问题，称之为 &lt;strong&gt;无锁编程&lt;/strong&gt;，这是一种不用加锁和解锁就可以安全的在多线程之间共享变化数据的技术。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;坏消息：这是非常底层的东西。比传统的同步原语比如互斥锁和信号量还底层多了：这次我们会更接近本质。尽管如此，我发现无锁编程是一个很好的思想挑战，也是一个非常好的更好理解计算机如何工作的机会。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;无锁编程依赖 &lt;strong&gt;原子指令&lt;/strong&gt;，这是CPU直接执行的原子操作。原子指令作为无锁编程的基础，我将在本文剩下的部分首先介绍，然后展示如何利用它做并发控制。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;什么是原子指令&quot;&gt;什么是原子指令？&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;思考计算中执行的任何操作，比如在屏幕上展示一张图片。这个操作是由许多更小的操作构成的：将文件读入内存，解压缩图片，点亮屏幕上的像素等等。如果你不停的细分这些更小的操作，也就是分为更小更小的操作，你最终会不能在分了。此时得到的处理器执行的肉眼可见的最小操作称之为 &lt;strong&gt;机器指令&lt;/strong&gt;，也就是硬件可直接执行的命令。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2020/02/images/software-hardware-layers.png&quot; alt=&quot;Software - hardware layers&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 1. 计算机程序的不同层次。虚线代表软件层次，实线代表硬件层次。
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;取决于不同的CPU架构，一些机器指令是原子的，也就是单个的，不能切分的，不会被中断的。一些其他的指令则不是原子的：处理器私底下以更小的操作的方式做了更多的工作，这些操作称之为 &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Micro-operation&quot;&gt;微指令&lt;/a&gt;&lt;/strong&gt;。让我们给出更正式的分类：原子指令是不能在细分的CPU指令。更确切的说，原子指令可以被归为2个主要类型：&lt;strong&gt;存储与加载&lt;/strong&gt; 和 &lt;strong&gt;读取-修改-写入（RMW）&lt;/strong&gt;。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;存储与加载原子指令&quot;&gt;存储与加载原子指令&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;存储和加载是处理器都需要的：用来写入（&lt;strong&gt;存储&lt;/strong&gt;）和读取（&lt;strong&gt;加载&lt;/strong&gt;）内存数据。在某些情况下，许多CPU架构保证这些操作是天然原子的。例如，实现了 &lt;a href=&quot;https://en.wikipedia.org/wiki/X86&quot;&gt;x86架构&lt;/a&gt;的处理器使用 &lt;strong&gt;MOV&lt;/strong&gt; 指令从内存中读取数据并交给CPU。这个操作如果处理的是 &lt;a href=&quot;https://www.ibm.com/support/knowledgecenter/en/SSUFAU_1.0.0/com.ibm.ent.pl1.zos.doc/lr/alnmnt.html&quot;&gt;对齐&lt;/a&gt;的数据就能保证是原子的，对齐的数据是指能让CPU一次性读取出来的方式存储的数据。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;读取_修改_写入rmw原子指令&quot;&gt;读取-修改-写入(RMW)原子指令&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;一些更复杂的操作不能够单独用一些简单存储和加载指令来完成。例如，增加存储中的数值需要至少3个原子的加载和存储指令，这就使的增加内存中数值这个操作不是原子的。&lt;strong&gt;读取-修改-写入（RMW）&lt;/strong&gt; 指令可以做到这个，也就有了通过一个原子操作完成多个操作的能力。除了RMW，还有非常多此类的指令。一些CPU架构全部提供，一些则提供一部分，下面列举一些：&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;ulist&quot;&gt; 
    &lt;ul&gt; 
     &lt;li&gt; &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Test-and-set&quot;&gt;测试并设置&lt;/a&gt; - 一个原子操作完成往内存中写入1并且返回赋值之前的值；&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fetch-and-add&quot;&gt;获取并增加&lt;/a&gt; - 一个原子操作完成增加内存中的数值并且返回增加之前的值；&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Compare-and-swap&quot;&gt;比较并交换（CAS）&lt;/a&gt; - 比较内存中的数据和提供的数据，如果他们是相同的，将提供的另一个数据写入该内存中。&lt;/p&gt; &lt;/li&gt; 
    &lt;/ul&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;以上这些操作都是一个原子操作完成多个操作。这是一个非常重要的特性，使得读取-修改-写入指令适合无锁多线程操作。我们很快就会看到为什么适合了。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;原子指令的三个层次&quot;&gt;原子指令的三个层次&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;以上所有这些指令都属于硬件层面的：他们直接和CPU交互。这种工作方式是非常困难并且不可移植，因为一些指令可能在不同得架构下叫不同得名字，一些指令在不同的处理器模型上则根本不存在！因此，你也不太可能用到这些，除非你在针对特定得机器写非常底层得代码。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;上到软件层面，许多操作系统提供了各自的原子指令。姑且称之为 &lt;strong&gt;原子操作(atomic operations)&lt;/strong&gt;，因为我们正在抽象出物理机器指令对应得原子操作。 例如， Windows系统上可能会用到 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/sync/interlocked-variable-access&quot;&gt;Interlocked API&lt;/a&gt;，这是一组原子方式处理变量得函数。 MacOS则用 &lt;a href=&quot;https://developer.apple.com/documentation/kernel/osatomic_h?language=objc&quot;&gt;OSAtomc.h&lt;/a&gt;头文件提供的函数做同样的事情。他们肯定是隐藏了硬件的具体实现，但是你还是受限于他们特定的环境。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;实现可移植原子操作的最好办法是使用你所选择的编程语言提供的原子操作。比如Java语言中有 &lt;strong&gt;java.util.concurrent.atomic&lt;/strong&gt; 包；C++提供了 &lt;strong&gt;std::atomic&lt;/strong&gt; 头文件； Haskell有 &lt;strong&gt;Data.Atomics&lt;/strong&gt; 包等等。一般来讲，如果一个编程语言能处理多线程，那就很有可能会提供原子操作的支持。这样的话就是编译器（如果是编译语言）或者虚拟机（如果是解析语言）负责从底层操作系统API或者硬件中找到最合适的指令来实现原子操作。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2020/02/images/atomics-levels.png&quot; alt=&quot;Three levels of atomic instructions&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 2. 原子指令和操作的层级。虚线代表软件层次，实线代表硬件层次。
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;例如，C++ 的编译器GCC通常是直接将 C++语言的原子操作和对象对应到机器指令。如果不能直接映射到硬件上，它也会利用其他可用的原子操作来实现特定操作。最坏情况下，在一个不提供原子操作的平台上，它可能利用其他阻塞策略来实现了，当然了这肯定不是无锁的实现。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;在多线程中使用原子操作&quot;&gt;在多线程中使用原子操作&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;我们现在看看原子操作是如何使用的。 考虑增加一个简单的变量，这本来就不是原子操作，因为此操作由3个不同的步骤构成：读取数值，给数值加1，将结果写回。 一般来说，你可能会使用互斥锁来正确实现这个操作（伪代码）：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;listingblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;mutex = initialize_mutex()
x     = 0

reader_thread()
    mutex.lock()
    print(x)
    mutex.unlock()

writer_thread()
    mutex.lock()
    x++
    mutex.unlock()&lt;/code&gt;&lt;/pre&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;首先获得互斥锁的线程会继续执行，而其他线程则等待第一个线程执行完毕。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;相反的，无锁方案使用了不同的模式：通过原子操作，线程可以随意执行而不用阻塞，例如：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;listingblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;x = 0

reader_thread()
    print(load(x))

writer_thread()
    fetch_and_add(x, 1)&lt;/code&gt;&lt;/pre&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;我假设了 &lt;code&gt;fetch_and_add()&lt;/code&gt; 和 &lt;code&gt;load()&lt;/code&gt; 是基于相应的硬件指令的原子操作。 你可能已经发现了，这里并没有使用锁。 并发调用这些函数的多个线程都可以继续执行。&lt;code&gt;load()&lt;/code&gt; 函数的原子性将保证不会有读线程读取到未完成修改的数据，同时因为 &lt;code&gt;fetch_and_add()&lt;/code&gt; 的原子性，也不会有写线程能够部分修改数据。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;现实世界中的原子操作&quot;&gt;现实世界中的原子操作&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;现在，上面这个例子显示了原子操作的一个重要特性：他们仅针对原子类型，如boolean型，字符串，整数等。但是真的程序是需要使用同步技术来实现更复杂的数据结构，比如数组，向量，对象，数据向量，对象里包含数据等等。如何用基于原子类型的简单操作来保证复杂数据的原子性？&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;无锁编程迫使你跳出常规的同步原语来思考问题。你不直接用原子操作保护共享资源，而是用互斥锁或者信号量。同样的，你会基于原子操作构建 &lt;strong&gt;无锁算法&lt;/strong&gt; 或者 &lt;strong&gt;无锁数据结构&lt;/strong&gt; 来确定多个线程如何访问你的数据。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;例如，上面看到的 &lt;em&gt;fetch-and-add&lt;/em&gt; 操作可以用来实现一个基本的信号量，而这个信号量就可以用来协调多个线程。毫无意外，所有传统的阻塞同步工具都是基于原子操作的实现的。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;人们写了很多个无锁数据结构，比如Folly的 &lt;a href=&quot;https://github.com/facebook/folly/blob/master/folly/AtomicHashMap.h&quot;&gt;AtomicHashMap&lt;/a&gt;， &lt;a href=&quot;https://www.boost.org/doc/libs/1_70_0/doc/html/lockfree.html&quot;&gt;Boost.Lockfree类库&lt;/a&gt;，多生产者/多消费者， &lt;a href=&quot;https://github.com/cameron314/concurrentqueue&quot;&gt;先进先出队列&lt;/a&gt;(FIFO)，或者诸如 &lt;a href=&quot;https://www.youtube.com/watch?v=rxQ5K9lo034&quot;&gt;读取-复制-更新（RCU）&lt;/a&gt;和 &lt;a href=&quot;https://en.wikipedia.org/wiki/Shadow_paging&quot;&gt;影子分页&lt;/a&gt;(Shadow Paging)等一些算法。从头开始写这些原子工具很困难，更不用说让他们正确工作。这也是大多数时候你可能会使用已经存在的，实战检验过得算法与数据结构，而不是使用自己实现的。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;比较并交换cas循环&quot;&gt;比较并交换(CAS)循环&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;具体到实际应用，&lt;strong&gt;比较并交换循环&lt;/strong&gt;(&lt;strong&gt;CAS loop&lt;/strong&gt;)可能是无锁编程中最常用的技巧，无论你是使用现成的数据结构或者从头开始实现算法。这是基于对应的 &lt;em&gt;比较并交换&lt;/em&gt; 原子操作（CAS）而且有一个很好的特点：他能支持多个写线程。这是用到复杂系统中的并发算法的一个重要特征。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;CAS循环非常有趣是因为他在无锁代码中引入了重复模式，同时引入了用于推理的理论概念。我们进一步看一下。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;cas循环实现&quot;&gt;CAS循环实现&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;操作系统或者编程语言提供的CAS函数可能是这样的：&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;listingblock&quot;&gt; 
    &lt;div class=&quot;content&quot;&gt; 
     &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;boolean compare_and_swap(shared_data, expected_value, new_value);&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;他的入参有共享数据的引用/指针，预期共享数据当前的值以及将要赋值的新值。这个函数只有在 &lt;code&gt;shared_date.value == expected_value&lt;/code&gt; 的情况下才会使用新数据替换原始数据，并且只有数据改变的情况下才返回 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;CAS循环的思路是不停的尝试比较和交换，直到操作成功。每一次尝试都需要给CAS函数传递共享数据的引用/指针，预期的数据和将要赋值的数据。这是和其他并发写线程配合的必要条件：如果其他线程在同步修改数据，也就是共享数据和预期数据不再匹配了，CAS函数就会失败。这样就支持了多个写线程。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;假设我们用CAS来实现前面代码片段实现的 &lt;code&gt;fetch-and-add&lt;/code&gt; 算法，实现起来可能是这样的（伪代码）：&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;listingblock&quot;&gt; 
    &lt;div class=&quot;content&quot;&gt; 
     &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;x = 0

reader_thread()
    print(load(x))

writer_thread()
    temp = load(x)                              &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    while(!compare_and_swap(x, temp, temp + 1)) &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;第（1）行代码加载共享数据，然后尝试和新的数据进行交换，直到交换成功返回 &lt;code&gt;true&lt;/code&gt;（2）。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;交换范式&quot;&gt;交换范式&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;正如前面说的，CAS循环在许多无锁算法中引入了重复模式:&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;olist arabic&quot;&gt; 
    &lt;ol class=&quot;arabic&quot;&gt; 
     &lt;li&gt; &lt;p&gt;创建共享数据的 &lt;em&gt;本地副本&lt;/em&gt;；&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;按需修改本地副本；&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;合适的时候，通过 &lt;em&gt;交换&lt;/em&gt; 更新后的数据与之前创建的副本数据来更新共享数据。&lt;/p&gt; &lt;/li&gt; 
    &lt;/ol&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;第3）点是关键：交换是通过原子操作来保证原子性的。本地写线程针对副本数据做了大部分的脏活累活，等到合适的时候才发布更新到共享数据。这样的话，其他线程只能看到这个共享数据的2种状态：未修改的数据和修改后的数据。由于原子交换，看不到修改过程中的中间状态，或者出错的更新。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;这也是哲学上不同于加锁方案的：无锁算法中，多线程仅仅在执行交换的时候才需要交互，其他时候都不被打扰的运行，也感知不到其他线程的存在。多线程之间的交互点缩小了并且被限制在执行原子操作的期间。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;一种轻量级加锁形式&quot;&gt;一种轻量级加锁形式&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;上面看到的 &lt;em&gt;循环直到成功&lt;/em&gt; 的策略在许多无锁算法中用到了，被称之为 &lt;strong&gt;自旋锁(spinlock)&lt;/strong&gt;：一个简单的循环，线程不停的尝试执行操作直到成功。这是一种轻量级的加锁形式，此时线程是实时活跃运行的，不会被操作系统休眠，尽管这个循环成功之前工作不会有进展。相比之下，互斥锁或者信号量中用到的常规锁代价非常高，因为一个挂起/唤醒周期需要大量的底层工作。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;aba问题&quot;&gt;ABA问题&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;行（1）和（2）所示指令虽然有所不同，但不是连续的。另一个线程可能插入中间，再（1）读取完成之后修改共享数据。更确切的说，另一个线程可以将初始数据，假设为A，修改为B，然后在（2）所示的比较并交换操作执行之前再修改回A。执行CAS操作的线程不会发现数据的变化而成功执行交换操作。这就是所谓的ABA问题：有时候你可以简单的直接忽略，如果你的算法就像上面那个一样简单，而有时候你就需要避免此问题，因为这会给你的应用程序引入非常难以发现的问题。幸运的是有 &lt;a href=&quot;https://en.wikipedia.org/wiki/Compare-and-swap#ABA_problem&quot;&gt;几种方式&lt;/a&gt; 可以绕过这个问题。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;cas循环可以交换任意的事情&quot;&gt;CAS循环可以交换任意的事情&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;CAS循环经常用来交换指针，这也是 &lt;em&gt;比较并交换&lt;/em&gt; 操作支持的类型之一。当你需要修改复杂的诸如对象或者数组的数据集的时候非常有用：创建本地数据副本，按需修改这个副本，合适的时候交换本地副本数据和全局共享数据的指针。这样的话全局共享数据就指向了本地副本数据在内存中指针，其他线程就会看到更新后的最新数据。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;这个技术允许你同步非基本数据实体(primitive entities)，尽管要做到这个也有一定的难度。比如交换完成之后，一个读线程还在读取老的指针？如何安全的删除之前的数据副本而不引起非常危险的野指针问题？工程师们再一次的找到了很多解决方案，比如使用支持内存自动 &lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&quot;&gt;垃圾回收&lt;/a&gt;的语言，或者一些深奥的技术如 &lt;a href=&quot;https://aturon.github.io/blog/2015/08/27/epoch/&quot;&gt;分代内存回收&lt;/a&gt;， &lt;a href=&quot;https://en.wikipedia.org/wiki/Hazard_pointer&quot;&gt;冒险指针&lt;/a&gt;或者 &lt;a href=&quot;https://en.wikipedia.org/wiki/Reference_counting&quot;&gt;引用计数&lt;/a&gt;。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;无锁和无等待&quot;&gt;无锁和无等待&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;每个基于原子操作的算法或者数据结构都可以归为2类：&lt;strong&gt;无锁的&lt;/strong&gt; 或者 &lt;strong&gt;无等待的&lt;/strong&gt;。当你要评估基于原子操作的类库对你应用程序性能的影响时，这是一个非常重要的不同点。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;无锁算法允许其他线程继续执行有用的工作，尽管有一个线程正在忙等。换句话说，至少有一个线程是可以继续执行的。CAS循环是一个非常好的无锁算法例子，因为循环的过程中如果有一些交换尝试失败了，一定是因为另一个线程成功修改了共享数据。尽管如此，无锁算法可能会在无法预知的时间内不停的忙等，尤其是有许多个线程在同时竞争同一个共享数据：更确切的说，当 &lt;strong&gt;竞争&lt;/strong&gt; 非常激烈的时候。极端情况下，一个无锁算法的CPU资源效率可能远远不及让线程阻塞休眠的互斥锁。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;相比之下，在无等待算法中（无锁算法的子集），任何线程都能够在有限的步骤内完成工作，无论执行速度是怎样的，或者其他线程的工作负载水平是怎样的。本文中基于 &lt;em&gt;fetch-and-add&lt;/em&gt; 操作的第一个代码片段就是一个无等待算法实例：没有循环，没有重试，就是干净的业务流。还有，无等待算法是 &lt;strong&gt;容错的&lt;/strong&gt;：任何其他线程的失败，或者执行速度的波动都不会使当前线程结束不了工作。这些特性使得无等待算法非常适合复杂的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Real-time_computing&quot;&gt;实时系统&lt;/a&gt;，因为这里并发代码的行为可预知是必要的。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2020/02/images/lock-free-wait-free.png&quot; alt=&quot;Lock-free&quot; width=&quot;wait-free&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 3. 无等待算法是无锁算法的子集
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;无等待是并发代码非常需要的，但也是很难获得的特性。总而言之，无论你正在构建一个阻塞的，无锁的还是无等待的算法，黄金法则是你一定要做基准测试并且衡量测试结果。有时候旧时的互斥锁比时髦的同步原语性能要好，尤其是并发任务的复杂度非常高的时候。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;写到最后&quot;&gt;写到最后&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;原子操作是无锁编码的必要组成，甚至在单处理器的机器上也是。没有原子性，一个线程可能在事务中途被中断，可能会导致不一致的数据状态。本文中，我仅仅是浅尝辄止：一旦你把多核/多线程考虑进去，就打开了新世界。&lt;strong&gt;顺序一致性&lt;/strong&gt; 和 &lt;strong&gt;内存屏障&lt;/strong&gt; 是非常关键的部分，如果要充分利用无锁算法，就不应该被忽视。我将在下一文章中讨论这些主题。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;Preshing on Programming - &lt;a href=&quot;https://preshing.com/20120612/an-introduction-to-lock-free-programming/&quot;&gt;An Introduction to Lock-Free Programming&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Preshing on Programming - &lt;a href=&quot;https://preshing.com/20130618/atomic-vs-non-atomic-operations/&quot;&gt;Atomic vs. Non-Atomic Operations&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Preshing on Programming - &lt;a href=&quot;https://preshing.com/20150402/you-can-do-any-kind-of-atomic-read-modify-write-operation/&quot;&gt;You Can Do Any Kind of Atomic Read-Modify-Write Operation&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;StackOverflow - &lt;a href=&quot;https://stackoverflow.com/questions/1525189/do-i-need-a-mutex-for-reading&quot;&gt;Do I need a mutex for reading?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;StackOverflow - &lt;a href=&quot;https://stackoverflow.com/questions/39795265/will-atomic-operations-block-other-threads&quot;&gt;Will atomic operations block other threads?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;StackOverflow - &lt;a href=&quot;https://stackoverflow.com/questions/38124337/spinlock-vs-busy-wait&quot;&gt;Spinlock vs Busy wait&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;GCC Wiki - &lt;a href=&quot;https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicTypes&quot;&gt;Atomics&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;GCC Wiki - &lt;a href=&quot;https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync&quot;&gt;Memory model synchronization modes&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Threading Building Blocks - &lt;a href=&quot;https://www.threadingbuildingblocks.org/docs/help/tbb_userguide/Atomic_Operations.html&quot;&gt;Atomic Operations&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Just Software Solutions - &lt;a href=&quot;https://www.justsoftwaresolutions.co.uk/threading/non_blocking_lock_free_and_wait_free.html&quot;&gt;Definitions of Non-blocking, Lock-free and Wait-free&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Compare-and-swap&quot;&gt;Compare-and-swap&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Read%E2%80%93modify%E2%80%93write&quot;&gt;Read-modify-write&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Test-and-set&quot;&gt;Test-and-set&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Tyler Neely - &lt;a href=&quot;https://medium.com/@tylerneely/fear-and-loathing-in-lock-free-programming-7158b1cdd50c&quot;&gt;Fear and Loathing in Lock-Free Programming&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Jason Gregory - &lt;a href=&quot;https://www.ebooks.com/en-us/95912264/game-engine-architecture-third-edition/jason-gregory/&quot;&gt;Game Engine Architecture, Third Edition&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;AA.VV. - &lt;a href=&quot;https://spcl.inf.ethz.ch/Publications/.pdf/atomic-bench.pdf&quot;&gt;Evaluating the Cost of Atomic Operations on Modern Architectures&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Herb Sutter, CppCon 2014 - &lt;a href=&quot;https://www.youtube.com/watch?v=c1gO9aB9nbs&quot;&gt;Lock-Free Programming (or, Juggling Razor Blades), Part 1&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Herb Sutter, CppCon 2014 - &lt;a href=&quot;http://www.youtube.com/watch?v=CmxkPChOcvw&quot;&gt;Lock-Free Programming (or, Juggling Razor Blades), Part 2&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Maurice Herlihy - &lt;a href=&quot;https://cs.brown.edu/~mph/Herlihy91/p124-herlihy.pdf&quot;&gt;Wait-free synchronization&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Fedor Pikus, CppCon 2014 - &lt;a href=&quot;https://www.youtube.com/watch?v=rxQ5K9lo034&quot;&gt;Read, Copy, Update, then what? RCU for non-kernel programmers&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;1024cores - &lt;a href=&quot;http://www.1024cores.net/home/lock-free-algorithms&quot;&gt;Lockfree Algorithms&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Microsoft - &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/dxtecharts/lockless-programming&quot;&gt;Lockless Programming Considerations for Xbox 360 and Microsoft Windows&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Brian Goetz, IBM - &lt;a href=&quot;https://www.ibm.com/developerworks/java/library/j-jtp11234/&quot;&gt;Going Atomic&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;本文译自https://www.internalpointers.com/post/lock-free-multithreading-atomic-operations，英文读者可直接阅读原文。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>线程同步: 多线程应用中最常见的并发控制方法之一</title>
                <link>https://www.reploop.org/blog/2020/02/introduction-to-thread-synchronization.html</link>
                <pubDate>Sun, 23 Feb 2020 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2020/02/introduction-to-thread-synchronization.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;本文讨论的是多线程应用中最常见的并发控制方法之一。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;就像我&lt;a href=&quot;https://www.reploop.org/blog/2020/02/a-gentle-introduction-to-multithreading.html&quot;&gt;前一篇文章&lt;/a&gt;所阐述的，开发并发代码需要技巧的。 会遇到两个大问题：数据竞争，当一个写线程在修改内存数据的同时一个读线程正在从中读取数据和竞争条件，当2个或以上的线程以不可预知的顺序执行任务的时候会发生。幸运的是我们有一些办法来避免这类错误：这篇文章我们就来看一个最常用的办法：&lt;strong&gt;同步(synchronization)&lt;/strong&gt;。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;div class=&quot;title&quot;&gt;
    本系列中的其他文章
   &lt;/div&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;&lt;a href=&quot;https://www.reploop.org/blog/2020/02/a-gentle-introduction-to-multithreading.html&quot;&gt;多线程简介&lt;/a&gt; - 一步一步走进并发的世界&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;a href=&quot;https://www.reploop.org/blog/2020/02/lock-free-multithreading-with-atomic-operations.html&quot;&gt;用原子操作实现无锁多线程&lt;/a&gt; - 底层线程同步&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;a href=&quot;https://www.reploop.org/blog/2020/02/understanding-memory-reordering.html&quot;&gt;理解内存重排序&lt;/a&gt; - 为什写无锁多线程代码时它很重要&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;什么是同步&quot;&gt;什么是同步&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;同步是让2个或以上线程和平共处的技巧合集。更确切的说，同步能够帮你实现多线程程序中至少2个重要的特性：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;olist arabic&quot;&gt; 
   &lt;ol class=&quot;arabic&quot;&gt; 
    &lt;li&gt; &lt;p&gt;&lt;strong&gt;原子性&lt;/strong&gt; - 如果你的代码包含多个线程操作共享数据的指令，不受控制的并发访问共享数据可触发数据竞争。包含此类指令的代码块称为关键区块。你要确保关键区块要原子执行：如前文所定义的，一个&lt;a href=&quot;https://www.reploop.org/blog/2020/02/a-gentle-introduction-to-multithreading.html&quot;&gt;原子操作&lt;/a&gt;不能在细分为更小的操作了，因此当一个线程在执行原子代码块的时候，就不会受到其他线程的干扰；&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;strong&gt;有序性&lt;/strong&gt; - 有时候你需要2个或以上的线程按照可预测的顺序执行任务，或者限制访问某个资源的线程数。正常情况下你是不能控制这个的，这也可能是竞争条件发生的根本原因。有了同步之后，你就可以根据计划来编排多个线程的执行了。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ol&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;同步是通过支持多线程的操作系统或者编程语言提供的 &lt;strong&gt;同步原语(synchronization primitives)&lt;/strong&gt; 来实现的。然后你就可以在代码中使用同步原语来保证多线程不会触发数据竞争、竞争条件或者全部。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;同步可以发生在硬件和软件，以及线程与操作系统进程之间。 这篇文章是关于软件线程同步：对应的硬件同步部分非常有趣，将会在后续的文章中介绍。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;常见同步原语&quot;&gt;常见同步原语&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;最重要的同步原语是互斥锁，信号量和条件变量。这些关键字还没有官方的定义，所以在不同的书本或者实现中会有轻微的不同特征。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这3个同步原语是操作系统是原生支持的。例如Linux和macOS支持 &lt;strong&gt;POSIX线程&lt;/strong&gt;，也就是 &lt;strong&gt;pthreads&lt;/strong&gt;，能够让你可以用这一组函数开发安全的多线程应用。Windows则用C运行时代码库（CRT）提供自己的同步工具：概念上和POSIX多线程功能相似但是不同的命名。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;除非你正在写非常底层的代码，通常你只要使用编程语言提供的同步原语就可以了。每个支持多线程的编程语言都提供了自己的同步原语工具箱，以及一些额外的线程处理功能。例如Java提供了 &lt;code&gt;java.util.concurrent&lt;/code&gt; 包，现代C++有自己的线程库，C#提供 &lt;code&gt;System.Threading&lt;/code&gt; 命名空间等等。当然所有这些功能和对象都是基于底层操作系统同步原语的。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;除此之外还有其他同步工具，但是本文只关注上面提到的3个，因为他们是构建复杂系统的基础。让我们进一步分析。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;互斥锁&quot;&gt;互斥锁&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;&lt;strong&gt;互斥锁&lt;/strong&gt;(&lt;strong&gt;mut&lt;/strong&gt;ual &lt;strong&gt;ex&lt;/strong&gt;clusion)是一个同步原语，是为了避免数据竞争而给关键区增加限制的保护机制。 互斥锁通过同时只允许一个线程访问关键区来保证 &lt;em&gt;原子性&lt;/em&gt;。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;严格来讲，互斥锁是应用中的一个全局对象，在多个线程之间共享，并且提供通常叫做 &lt;code&gt;加锁&lt;/code&gt; 和 &lt;code&gt;解锁&lt;/code&gt; 的2个功能函数。一个即将要进入关键区域的线程通过 &lt;code&gt;加锁&lt;/code&gt; 操作锁定这个互斥锁，结束后，也就是关键区域结束之后，同样的线程调用 &lt;code&gt;解锁&lt;/code&gt; 操作来释放这个互斥锁。互斥锁非常重要的特性是：只有锁定这个互斥锁的线程才能解锁。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;如果一个线程正在关键区，而另一个线程尝试锁定这个互斥锁，操作系统就让后面这个线程休眠，直到第一个线程任务结束并且释放了这个互斥锁。这样就只有1个线程可以访问关键区，任何其他线程都不能访问而且必须等待互斥锁的释放。基于这个原因，互斥锁也叫做锁机制。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;你可以用互斥锁保护比如一个共享变量的并发读和写操作，也可以保护更大、更复杂的操作，同时只允许一个线程执行的，比如写日志文件或者修改数据库。无论如何，互斥锁的加锁/解锁操作总是和关键区的边界是匹配的。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;互斥锁保护的是关键区域，也就是操作，而不是数据本身。如果在关键区域之外的代码也能读写数据，互斥锁就有失效的风险。所以所有对数据有读写的代码都需要作为关键区用互斥锁保护起来才能避免数据竞争。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;递归互斥锁&quot;&gt;递归互斥锁&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;许多常规的互斥锁实现中，一个线程两次加锁同一个互斥锁会引起错误。但是 &lt;strong&gt;递归互斥锁(recursive mutex)&lt;/strong&gt; 允许此类操作：一个线程可以锁定一个递归互斥锁许多次而不需要先释放。尽管如此，其他线程只有等到第一个线程释放所有的递归互斥锁之后才能锁定这个锁。这个同步原语也叫做 &lt;strong&gt;可重入互斥锁(reentrant mutex)&lt;/strong&gt;，这里的 &lt;strong&gt;可重入性(reentrancy)&lt;/strong&gt; 是指在前一次调用结束之前可以多次调用同一个函数的能力。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;递归互斥锁很难用而且容易出错。你必须记录哪个线程锁定了哪个互斥锁多少次，而且要保证一个线程完全释放这个互斥锁。不然的话就会导致互斥锁没能释放而引起讨厌的后果。大多数时候正常的互斥锁就够用了。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;读写锁&quot;&gt;读写锁&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;正如我们从前一篇文章中知道的，多个线程可以安全的并发读一个共享资源，只要没有线程修改该共享资源。所以如果一些线程是“只读”模式的，还有必要锁定一个互斥锁？例如一个并发数据库被多个线程频繁读取，同时另一个线程偶尔写入更新。你当然需要一个互斥锁来保护读/写访问，但是大多数情况下仅仅为了读操作而锁定一个互斥锁，也同时阻碍了其他读线程正常执行。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;&lt;strong&gt;读/写互斥锁&lt;/strong&gt; 允许多线程 &lt;em&gt;并发&lt;/em&gt; 读和单线程 &lt;em&gt;排他&lt;/em&gt; 写共享资源。这个互斥锁可以被锁定为 &lt;em&gt;读模式&lt;/em&gt; 或者 &lt;em&gt;写模式&lt;/em&gt;。为了修改资源，一个线程必须先获得排他写入锁。排他写入锁直到所有的读取锁全部释放之后才能获取。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;信号量&quot;&gt;信号量&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;&lt;strong&gt;信号量&lt;/strong&gt; 是用来编排线程的同步原语：那个线程先启动，多少个线程可以访问一个资源等等。就像“红绿灯”调节交通一样，程序信号量规范多线程交互流程：基于这个原因，信号量也称为 &lt;strong&gt;信号机制&lt;/strong&gt;。他可以被看做互斥锁的进化，因为他能同时保证 &lt;em&gt;有序性&lt;/em&gt; 和 &lt;em&gt;原子性&lt;/em&gt;。尽管如此，接下来的几段中我讲告诉你为什么仅仅为了原子性而使用信号量不是一个好选择。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;严格来讲，信号量是应用中的全局变量，多个线程间共享，还包含了一个 &lt;em&gt;计数器&lt;/em&gt;，通过2个函数管理：一个增加计数器，另一个减少计数器。历史上，这两个操作分别叫做 &lt;code&gt;P&lt;/code&gt; 操作和 &lt;code&gt;V&lt;/code&gt; 操作，现代信号量的实现使用更友好的名字比如 &lt;code&gt;获取&lt;/code&gt; 和 &lt;code&gt;释放&lt;/code&gt;。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;信号量控制共享资源的访问：计数器决定了并行访问共享资源的最大线程数。程序启动的时候，也就是信号量被初始化的时候，你根据自己的需要选择这个最大线程数。然后一个想访问共享资源的线程调用 &lt;code&gt;获取&lt;/code&gt; 函数：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;如果计数器 &lt;em&gt;大于0&lt;/em&gt; 就继续进行。计数器被立即减少1，然后当前线程可以开始操作了。结束后，当前线程调用 &lt;code&gt;释放&lt;/code&gt; 函数，同时计数器加1.&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;如果计数器 &lt;em&gt;等于0&lt;/em&gt; 则此线程不能继续进行：其他线程已经占用了可以空间。当前线程被操作系统休眠，只有等到信号量的计数器再次大于0（也就是有线程完成任务后调用了 &lt;code&gt;释放&lt;/code&gt; 函数）的时候才会被唤醒。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;不像互斥锁，&lt;em&gt;任何线程可以释放信号量&lt;/em&gt;，不仅仅是最先获取信号量的线程。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;单个信号量可以用来限制同时访问共享资源的线程数：例如为了控制多线程数据库的连接数，这其中的每个线程是连接到你的服务器的用户触发的。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;结合多个信号量一起，你就可以解决线程的有序性问题了：比如在浏览器中渲染网页的线程必须在通过互联网下载HTML文件的线程之后启动。线程A结束的时候会通知线程B，因此线程B可以被唤醒继续执行任务：这个也常被称为著名的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem&quot;&gt;生产者-消费者问题&lt;/a&gt;。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;二元信号量&quot;&gt;二元信号量&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;如果信号量的计数器只允许取值0和1，则称之为 &lt;strong&gt;二元信号量&lt;/strong&gt;：也就是同时只允许一个线程访问共享资源。 等一下，这基本上就是互斥锁保护关键区的作用。你确实可以用二元信号量来实现互斥锁的行为。但是要时刻牢记以下2点：&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;olist arabic&quot;&gt; 
    &lt;ol class=&quot;arabic&quot;&gt; 
     &lt;li&gt; &lt;p&gt;互斥锁只能被加锁的线程解锁，但是信号量可以被任意线程释放。如果你仅仅需要一个锁机制的话，这会导致困惑和微妙的问题；&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;信号量是用来编排线程的信号机制，但是互斥锁是保护共享资源的锁机制。你不应改使用信号量来保护共享资源，也不应该将互斥锁用于信号机制：这样你的意图对你和你的代码读者会更明确。&lt;/p&gt; &lt;/li&gt; 
    &lt;/ol&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;条件变量&quot;&gt;条件变量&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;条件变量是另一个用来保证 &lt;em&gt;有序性&lt;/em&gt; 的同步原语。他们是用来在不同线程之间发送唤醒信号的。条件变量往往配合互斥锁一起使用，单独使用条件变量没有意义。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;严格来讲，条件变量是应用中的全局对象，多个线程之间共享，提供3个函数，分别叫做：&lt;code&gt;wait&lt;/code&gt;，&lt;code&gt;notify_one&lt;/code&gt; 和 &lt;code&gt;notify_all&lt;/code&gt;, 外加一个传递已知互斥锁给他配合工作的机制（具体方法依实现而定）。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;线程调用一个条件变量的 &lt;code&gt;wait&lt;/code&gt; 操作会被操作系统休眠。然后其他的线程想要唤醒休眠线程的话就调用 &lt;code&gt;notify_one&lt;/code&gt; 或者 &lt;code&gt;notify_all&lt;/code&gt;。&lt;code&gt;notify_one&lt;/code&gt; 和 &lt;code&gt;notify_all&lt;/code&gt; 的不同之处是 &lt;code&gt;notify_one&lt;/code&gt; 仅仅唤醒一个休眠线程，但是 &lt;code&gt;notify_all&lt;/code&gt; 会唤醒所有因为调用了条件变量的等待操作而休眠的线程。条件变量内部使用互斥锁提供休眠/唤醒机制。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;条件变量是仅靠互斥锁实现不了的在线程之间发送信号的强大机制。例如你也可以使用它解决生产者-消费者问题，线程A完成任务后产生一个信号，接着线程B就可以开始执行任务了。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;常见的同步问题&quot;&gt;常见的同步问题&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;本文所述的所有同步原语有共同之处：都会让线程休眠。基于这个原因，他们也被叫做 &lt;strong&gt;阻塞机制&lt;/strong&gt;。如果你想避免数据竞争或者竞争条件，阻塞机制是防止并发访问共享资源的好办法：休眠线程不会有任何害处。但是他能够触发不幸的副作用，我们来看看都有哪些。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;死锁&quot;&gt;死锁&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;&lt;strong&gt;死锁&lt;/strong&gt; 发生在一个线程等待另一个线程持有的共享变量，而第二个线程在等待第一个线程持有的共享变量。这种情况通常在使用多个互斥锁的时候发生：2个线程在死循环中永久等待：线程A在等待线程B，线程B在等待线程A，而线程A又在等待线程B，如此往复。。。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;饥饿线程&quot;&gt;饥饿线程&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;当线程没有得到足够的爱就进入 &lt;strong&gt;饥饿&lt;/strong&gt; 模式：它永远卡在休眠模式等待访问共享资源，但是这个共享资源持续的给了其他线程。例如一个基于信号量的糟糕实现可能会忘记唤醒等待队列中的一些线程，这个可以通过给部分线程高优先级的方式实现。饥饿线程会永久等待而不能做任何有效的工作。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;无效唤醒&quot;&gt;无效唤醒&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;这是一些操作系统中条件变量的具体实现方式带来的微妙问题。一个 &lt;strong&gt;无效唤醒&lt;/strong&gt; 可能是线程没有收到条件变量的信号而被唤醒了。这也是多数同步原语中包含了检查唤醒信号是否真的来自线程正在等待的条件变量的方法的原因。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;优先级反转&quot;&gt;优先级反转&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;&lt;strong&gt;优先级反转&lt;/strong&gt; 是一个执行高优先级任务的线程阻塞等待一个低优先级的线程释放资源，如互斥锁。例如输出音频到声卡的线程（高优先级）被显示界面的线程（低优先级）阻塞了，会导致扬声器严重的卡顿。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;下一步&quot;&gt;下一步&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这些同步问题被研究很多年了，也有很多技术和架构方面的解决方法。严谨的设计和一些实际经验能很大程度上预防问题的发生。鉴于多线程程序的&lt;a href=&quot;https://www.reploop.org/blog/2020/02/a-gentle-introduction-to-multithreading.html&quot;&gt;不确定性&lt;/a&gt;(非常难的)性质，也有人开发出来在并发代码中检测错误和潜在缺陷的有趣工具。就像 &lt;a href=&quot;https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual&quot;&gt;Google的TSan&lt;/a&gt;或者 &lt;a href=&quot;http://valgrind.org/docs/manual/hg-manual.html&quot;&gt;Helgrind&lt;/a&gt;一样。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;尽管如此，有时候你可能在多线程应用中采用不同的方法，完全去掉阻塞机制。这意味着进入 &lt;strong&gt;非阻塞&lt;/strong&gt; 领域：这是一个非常底层的领域，线程不会被操作系统休眠，并发是通过 &lt;strong&gt;原子操作&lt;/strong&gt; 和 &lt;strong&gt;无锁数据结构&lt;/strong&gt; 规范的。这是一个充满挑战的领域，并不总是有必要，但是它能够加速你的软件或者对他造成严重的破坏。不过这是下一篇文章的内容。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29#Thread_or_process_synchronization&quot;&gt;Synchronization (computer science)&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Reentrant_mutex&quot;&gt;Reentrant mutex&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Reentrancy_%28computing%29&quot;&gt;Reentrancy (computing)&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Semaphore_%28programming%29&quot;&gt;Semaphore (programming)&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious_wakeup&quot;&gt;Spurious Wakeup&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Priority_inversion&quot;&gt;Priority inversion&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Starvation_%28computer_science%29&quot;&gt;Starvation (computer science)&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Columbia Engineering - &lt;a href=&quot;http://www.cs.columbia.edu/~hgs/os/sync.html&quot;&gt;Synchronization primitives&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;StackOverflow - &lt;a href=&quot;https://stackoverflow.com/questions/8017507/definition-of-synchronization-primitive&quot;&gt;Definition of “synchronization primitive”&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;StackOverflow - &lt;a href=&quot;https://stackoverflow.com/questions/2332765/lock-mutex-semaphore-whats-the-difference&quot;&gt;Lock, mutex, semaphore… what’s the difference?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;StackOverflow - &lt;a href=&quot;https://stackoverflow.com/questions/11173532/why-is-locking-a-stdmutex-twice-undefined-behaviour&quot;&gt;Why is locking a std::mutex twice &apos;Undefined Behaviour&apos;?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Operating Systems: Three Easy Pieces - &lt;a href=&quot;http://pages.cs.wisc.edu/~remzi/OSTEP/&quot;&gt;Concurrency&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Jaka’s Corner - &lt;a href=&quot;http://jakascorner.com/blog/2016/01/data-races.html&quot;&gt;Data race and mutex&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Java 10 API specs - &lt;a href=&quot;https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/Semaphore.html&quot;&gt;Class Semaphore&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Oracle’s Multithreaded Programming Guide - &lt;a href=&quot;https://docs.oracle.com/cd/E19455-01/806-5257/6je9h032t/index.html&quot;&gt;Read-Write Lock Attributes&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Oracle’s Multithreaded Programming Guide - &lt;a href=&quot;https://docs.oracle.com/cd/E19455-01/806-5257/6je9h0347/index.html&quot;&gt;Avoiding Deadlock&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Just Software Solutions - &lt;a href=&quot;https://www.justsoftwaresolutions.co.uk/threading/locks-mutexes-semaphores.html&quot;&gt;Locks, Mutexes, and Semaphores: Types of Synchronization Objects&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Just Software Solutions - &lt;a href=&quot;https://www.justsoftwaresolutions.co.uk/threading/non_blocking_lock_free_and_wait_free.html&quot;&gt;Definitions of Non-blocking, Lock-free and Wait-free&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Cppreference - &lt;a href=&quot;https://en.cppreference.com/w/cpp/thread/shared_mutex&quot;&gt;std::shared_mutex&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Cppreference - &lt;a href=&quot;https://en.cppreference.com/w/cpp/thread/condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Quora - &lt;a href=&quot;https://www.quora.com/What-is-the-difference-between-a-mutex-and-a-semaphore&quot;&gt;What is the difference between a mutex and a semaphore?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;gerald-fahrnholz.eu - &lt;a href=&quot;http://www.gerald-fahrnholz.eu/sw/online_doc_multithreading/html/group___grp_condition_variable_safe_way.html&quot;&gt;Using condition variables - the safe way&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Politecnico di Milano - &lt;a href=&quot;http://home.deib.polimi.it/loiacono/uploads/Teaching/CP/CP_04_Pthread_CondVar.pdf&quot;&gt;Thread Posix: Condition Variables&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;SoftwareEngineering - &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/186842/spurious-wakeups-explanation-sounds-like-a-bug-that-just-isnt-worth-fixing-is&quot;&gt;Spurious wakeups explanation sounds like a bug that just isn’t worth fixing, is that right?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Android Open Source Project - &lt;a href=&quot;https://source.android.com/devices/audio/avoiding_pi&quot;&gt;Avoiding Priority Inversion&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;本文译自https://www.internalpointers.com/post/introduction-thread-synchronization，英文读者可直接阅读原文。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>多线程简介: 一步一步走进并发的世界</title>
                <link>https://www.reploop.org/blog/2020/02/a-gentle-introduction-to-multithreading.html</link>
                <pubDate>Thu, 20 Feb 2020 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2020/02/a-gentle-introduction-to-multithreading.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;现代计算机有同时执行多个任务的能力。在高级硬件和更智能的操作系统的支持下，计算机的这个能力能够让你的程序在执行时间和响应速度两方面体现的更快。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;开发利用这个能力的软件是既有趣又需要技巧：它要求你理解计算机的底层细节。在本系列的第一篇文章中，我尝试浅显介绍一下 &lt;strong&gt;线程（thread）&lt;/strong&gt;。操作系统为做到同时执行多个任务提供了很多工具，线程是其一。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;div class=&quot;title&quot;&gt;
    本系列中的其他文章
   &lt;/div&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;&lt;a href=&quot;https://www.reploop.org/blog/2020/02/introduction-to-thread-synchronization.html&quot;&gt;线程同步简介&lt;/a&gt; - 多线程应用中最常见的并发控制方法之一&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;a href=&quot;https://www.reploop.org/blog/2020/02/lock-free-multithreading-with-atomic-operations.html&quot;&gt;用原子操作实现无锁多线程&lt;/a&gt; - 底层线程同步&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;a href=&quot;https://www.reploop.org/blog/2020/02/understanding-memory-reordering.html&quot;&gt;理解内存重排序&lt;/a&gt; - 为什写无锁多线程代码时它很重要&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;进程与线程用正确的方式命名&quot;&gt;进程与线程：用正确的方式命名&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;现代操作系统能够同时执行多个程序。这就是你在用浏览器（一个程序）看这篇文章的同时还能够用多媒体播放器（另一个程序）听音乐的原因。每个程序就是一个正在被执行的 &lt;strong&gt;进程（process）&lt;/strong&gt;。操作系统知道许多软件层面的技巧，或者利用底层硬件使得多个程序并行执行。不管那种方式，最终结果就是你 &lt;em&gt;感觉&lt;/em&gt; 到所有的程序就是同时运行的。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;在操作系统中运行多个进程不是同时执行多个任务的唯一办法。每个进程内部可以同时运行多个子任务，称之为 &lt;strong&gt;线程&lt;/strong&gt;。你可以把线程看作是进程的一部分。 每个进程在启动时会至少会创建1个线程，这个线程叫做 &lt;strong&gt;主线程(main thread)&lt;/strong&gt;。然后，根据程序或者程序员的需要，更多的线程会被启动或者中止。&lt;strong&gt;多线程技术(Multithreading)&lt;/strong&gt; 是指在一个进程内运行多个线程。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;例如，多媒体播放器可能是多线程的：1个线程负责绘制界面（通常是主线程），另1个线程则负责播放音乐，如此类推。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;你可以把操作系统看作是包含了多个进程的容器。而每个进程则是包含了多个线程的容器。这篇文章中，我只会将重点放在线程上，但是整个主题是非常有趣的，在未来的文章会会有更深入的分析。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2020/02/images/processes-threads.png&quot; alt=&quot;Processes vs Threads&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 1. 操作系统可看作高包含多个进程的盒子，而进程则是包含了至少一个线程的盒子
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;进程与线程的不同之处&quot;&gt;进程与线程的不同之处&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;每个进程都有操作系统为其分配的内存块。默认情况下，进程的内存块不能够和其他进程共享：你的浏览器是不能访问分配给多媒体播放器的内存块的，反之亦然。如果你运行一个程序的两个 &lt;strong&gt;实例(instances)&lt;/strong&gt;，规则也是一样的。比如你打开2个浏览器。操作系统把每个实例看作是一个新的拥有独立内存块的进程。所以，默认情况下，2个或者更多的进程之间没法共享数据，除非使用高级的技巧，也就是所谓的 &lt;strong&gt;进程间通信(&lt;a href=&quot;https://en.wikipedia.org/wiki/Inter-process_communication&quot;&gt;IPC&lt;/a&gt;)&lt;/strong&gt;。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;不像进程，线程则共享了操作系统分配给其所在进程的内存块：多媒体播放器的音频引擎可很容易的访问播放器界面上的数据，反之亦然。因此线程间通信要比进程间通信容易多了。更重要的是，线程通常比进程轻量：线程占用较少的资源并且创建速度更快，这也是线程被称为 &lt;strong&gt;轻量级进程(lightweight processes)&lt;/strong&gt; 的原因。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;线程是同时执行多个操作的更方便的办法。没有线程，你需要为每个任务写一个程序，然后按进程运行并且通过操作系统来同步这些进程。这样会更难（IPC需要技巧）而且慢（进程比线程更重量级）。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;绿色线程或纤程&quot;&gt;绿色线程，或纤程&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;到目前为止，线程是操作系统级别的：一个进程启动一个线程需要和操作系统交互。但是并不是每种操作系统都原生支持线程。&lt;strong&gt;绿色线程(Green threads)&lt;/strong&gt;，也称为 &lt;strong&gt;纤程(fibers)&lt;/strong&gt; 是一种在不支持线程的环境下通过软件模拟的多线程从而使得多线程程序能够工作。比如一个虚拟机可能会实现绿色线程以防底层依赖的操作系统不支持原生的线程。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;绿色线程能够更快的创建和管理，因为绿色线程完全绕过了操作系统。但是也有其不足之处。我会在后续的文章中写这个主题。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;『绿色线程』的名字是指90年代太阳微系统公司的内最初设计Java线程库的『绿色团队』。今天Java不在使用绿色线程了，2000年的时候Java从绿色线程切换到操作系统原生线程了。有部分其他语言（随便举几个例子Go，Haskell或者Rust）实现了原生线程对应的绿色线程。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;线程用来干什么的&quot;&gt;线程用来干什么的&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;为啥一个进程要使用多个线程？ 如前所述，并行做事能够很大程度上加快速度。比如你准备用电影编辑器渲染一部电源，电影编辑器能够智能的把渲染任务分散到多个线程，每个线程处理这部电影的一部分。那么如果单线程执行这个任务要话1小时，用2个线程可能只需要30分钟，用4个线程可能只需要15分钟，依此类推。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;真的如此简单吗？有3个重要的点要考虑：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;olist arabic&quot;&gt; 
   &lt;ol class=&quot;arabic&quot;&gt; 
    &lt;li&gt; &lt;p&gt;并不是每个程序都需要多线程运行。如果你的程序执行串行操作或者经常等待用户做一些事情，多线程可能并不会有多大好处；&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;你不能不停的创建线程来让他运行更快：每个子任务都要仔细的思考和设计，才能执行并行操作。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;不能百分百的保证所有的线程是真正的平行执行的。也就是在 &lt;strong&gt;同一时刻&lt;/strong&gt;，是否真的并行取决于底层硬件。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ol&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;最后一点比较关键：如果你的计算机不支持同时执行多个操作，那么操作系统就要模拟多线程。我们马上就会看到如何做了。 目前而言，让我们把 &lt;strong&gt;并发(concurrency)&lt;/strong&gt; 认为是我们感觉多个任务在同时执行，而把 *真正的并行(true parallelism)*认为是多个任务真正的同时执行。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2020/02/images/concurrency-parallelism.png&quot; alt=&quot;Concurrency vs Parallelism&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 2. 并行是并发的子集。
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;并发和并行的背后原理&quot;&gt;并发和并行的背后原理&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;计算机中的中央处理单元(CPU)是真正负责运行程序的。它有几部分构成，主要部分就是所谓的 &lt;strong&gt;核（core）&lt;/strong&gt;：所有的计算都是在核上执行的。一个核一次只能执行一个操作。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这当然也是一个主要缺点。 由于这个原因，操作系统发展出许多高级的技术才让用户能够一次运行多个进程（或者线程），特别是图形界面环境甚至是单核机器上。最重要的一个是 &lt;strong&gt;抢占式多任务(preemptive multitasking)&lt;/strong&gt; 技术。其中 &lt;strong&gt;抢占式(preemption)&lt;/strong&gt; 是指操作系统能够中断当前正在运行的任务，切换到另一个任务并且一段时间之后还能够继续执行之前被中断的程序。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;所以如果你的CPU是单核的，操作系统的部分工作就是将单核的算力分配给多个进程或者线程，这些进程或者线程是一个接着一个的不停执行的。这个操作会让你有个幻觉至少2个程序在并行运行，或者某个程序在同时做多个事情（如果是多线程程序的话）。并发是满足了，但是真正的平行，也就是 &lt;em&gt;同时&lt;/em&gt; 运行多个进程的能力还是缺失的。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;今天现代CPU有不止1个核，而且同一时刻，每个核都可以独立的执行操作。 拥有2个或者更多的核心意味着真正的并行是可能的。例如，我的Intel Core i7是4核的：也就是说在某个时刻，它可以同时运行4个不同的进程或者线程。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;操作系统能够检测到CPU的核数并且分配进程或者线程给每个单独的核。操作系统可以调度自己喜欢的任意的核给一个线程，并且这种类型的调度对正在运行的程序是完全透明的。除此之外，抢占式多线程技术也可能在所有的核心都被占用的情况下生效。这能够让你运行多于机器实际拥有的核心数的程序。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;多线程应用程序跑在单核上有意义吗&quot;&gt;多线程应用程序跑在单核上：有意义吗？&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;在单核机器上是不可能实现真正的并行的。 不过如果你的应用程序能从中获益的话，写一个多线程程序仍然是有意义的。当一个应用程序使用了多线程，抢占式多任务技术能够让该应用跑起来，那怕是其中有些线程执行的是很慢的或者阻塞的任务。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;比如你正在开发一个桌面应用程序从非常慢的磁盘上读出数据。如果你仅仅用单线程写这个程序，整个应用就会卡死，直到磁盘操作完成：被分配给唯一线程的CPU再等待磁盘唤醒的过程中完全浪费了。当然操作系统可以运行除此之外的其他程序，但是你的这个应用程序不会有任何响应了。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;我们来用多线程重新考虑这个应用。 线程A负责磁盘读取，同时线程B负责主界面。如果线程A卡在等待很慢的设备，线程B仍然再运行主界面，这就能保证你的应用程序有响应。这是因为有2个线程的话，操作系统可以在2个线程之间切换CPU资源，这样就不用卡在那个慢的上。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;线程越多问题越多&quot;&gt;线程越多，问题越多&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;如我们所知，线程会共享所在进程的内存块。这极大的简化了一个进程中2个或者多个线程之间交换数据。例如；一个电影编辑器可能持有了共享内存中包含视频时间线的一大部分。这部分共享内存会被多个用于渲染影片的工作线程访问。所有这些线程仅仅需要内存的一个句柄（比如指针）来读取数据并且将渲染后的帧写到磁盘上。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;只要所有的线程都从内存中 &lt;em&gt;读取&lt;/em&gt; 数据，程序就能够平滑运行。但是只要有一个线程 &lt;em&gt;写入&lt;/em&gt; 共享内存，同时其他线程读取共享内存就会引起问题。在这种情况下会产生两种问题:&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;&lt;strong&gt;数据竞争&lt;/strong&gt; - 当一个写线程在修改内存的时候， 一个读线程可能正在读内存。 如果写线程没有完成写入， 读线程就会得的损坏的数据；&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;strong&gt;竞争条件&lt;/strong&gt; - 一个读线程只有在写线程写入数据之后才应该读数据。如果顺序反过来会怎样？比数据竞争更难理解，竞争条件是指2个或以上的线程以不可预知的顺序执行，事实上这些操作需要按照合适的顺序执行才能得到正确的结果。你的程序可触发竞争条件，即使是它已经有数据竞争保护。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;线程安全性的概念&quot;&gt;线程安全性的概念&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;我们说一段程序是线程安全的，是说这段程序能够正确工作，即使多个线程同时执行，也没有数据竞争或者竞争条件。你可能已经发现了一些程序类库声称自己是线程安全的：如果你正在写一个多线程程序，你要确保任何第三方函数可以在多个线程间调用而不会触发并发问题。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;数据竞争的根本原因&quot;&gt;数据竞争的根本原因&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;我们知道一个CPU核某一时刻只能执行一条机器指令。 这种指令是 &lt;strong&gt;原子的(atomic)&lt;/strong&gt;，因为他不能再细分了：它不能再细分为更小的操作了。『atom』在希腊语中是 &lt;em&gt;不可再分割&lt;/em&gt; 的意思。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;不能再细分的性质使得原子操作是天然的线程安全的。当一个线程执行一个原子写数据操作，没有其他线程能够读到未完成修改的数据。相反的，当一个线程执行一个原子读操作，它能读出完整的数据。线程是不能干扰一次原子操作的，因此也不会有数据竞争发生。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;坏消息是大部分操作都不是原子的。即使一个简单的赋值操作如 &lt;code&gt;x = 1&lt;/code&gt; 在一些硬件上也可能是由多个原子机器指令组成的，这就造成了这个赋值语句本身不是一个原子操作。当一个线程读取 &lt;code&gt;x&lt;/code&gt; 的值而另一个现在正在赋值就会触发数据竞争。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;竞争条件的根本原因&quot;&gt;竞争条件的根本原因&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;抢占式多任务技术给了操作系统对线程管理的完全控制：根据高级调度算法，它可以启动，停止和暂停线程。作为程序员是控制不了程序执行的时间或者顺序的。事实上，没有任何保证如下这段简单的程序：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;listingblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;writer_thread.start()
reader_thread.start()&lt;/code&gt;&lt;/pre&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;能够按照书写顺序依次启动2个线程。多运行几次这段程序，你就会发现每次执行之间的不同表现：有时候写线程先启动，有时候确实读线程先启动。如果你的程序需要写线程总是先于读线程启动，这就一定会碰到竞争条件。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这个行为称为 &lt;strong&gt;不确定性(non-deterministic)&lt;/strong&gt;：每次执行的结果是变化的而且你不能预测到。调试竞争条件相关的程序是非常讨厌的，因为你不能用受控的方式每次都重现此问题。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;让线程和平共处并发控制&quot;&gt;让线程和平共处：并发控制&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;数据竞争和竞争条件都是真实世界中的问题：一些人甚至是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Therac-25&quot;&gt;因此而丧命&lt;/a&gt;。协调2个或者更多并发线程的技术叫 &lt;strong&gt;并发控制(concurrency control)&lt;/strong&gt;：操作系统和编程语言提供了处理并发控制的一些解决方案。最重要的一些方案如下：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;&lt;strong&gt;同步&lt;/strong&gt; - 保证资源某一时刻只能被一个线程使用的方法。同步方法将特定代码块保护起来，使得2个或者更多的并发线程不能同时执行它，否则就会损坏你的共享数据；&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;strong&gt;原子操作&lt;/strong&gt; - 由于操作系统提供了一些特殊的指令，使得一批非原子操作（如上文提到的赋值操作）可以被转化为原子操作。这样的话共享数据总是有效的状态，不论其他线程如何访问它。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;strong&gt;不可变数据&lt;/strong&gt; - 共享数据被标记为不可变的，谁都不能修改它：线程只允许读数据，消除了根本原因。 就像我们所知的，线程可以安全的从同样的内存读数据，只要这个数据不会被修改。这也是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Functional_programming&quot;&gt;函数式编程&lt;/a&gt;背后的主要哲学。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;我会在这个关于并发的迷你系列的后续文章中讨论这些有趣的主题，保持关注。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;ulist&quot;&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;8 bit avenue - &lt;a href=&quot;https://www.8bitavenue.com/difference-between-multiprogramming-multitasking-multithreading-and-multiprocessing/&quot;&gt;Difference between Multiprogramming, Multitasking, Multithreading and Multiprocessing&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Inter-process_communication&quot;&gt;Inter-process communication&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Process_%28computing%29&quot;&gt;Process (computing)&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Concurrency_%28computer_science%29&quot;&gt;Concurrency (computer science)&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Parallel_computing&quot;&gt;Parallel computing&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Multithreading_%28computer_architecture%29&quot;&gt;Multithreading (computer architecture)&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Stackoverflow - &lt;a href=&quot;https://stackoverflow.com/questions/1713554/threads-processes-vs-multithreading-multicore-multiprocessor-how-they-are&quot;&gt;Threads &amp;amp; Processes Vs MultiThreading &amp;amp; Multi-Core/MultiProcessor: How they are mapped?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Stackoverflow - &lt;a href=&quot;https://stackoverflow.com/questions/19225859/difference-between-core-and-processor&quot;&gt;Difference between core and processor?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Thread_%28computing%29&quot;&gt;Thread (computing)&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Computer_multitasking&quot;&gt;Computer multitasking&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Ibm.com - &lt;a href=&quot;https://www.ibm.com/support/knowledgecenter/en/ssw_aix_71/generalprogramming/benefits_threads.html&quot;&gt;Benefits of threads&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Haskell.org - &lt;a href=&quot;https://wiki.haskell.org/Parallelism_vs._Concurrency&quot;&gt;Parallelism vs. Concurrency&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Stackoverflow - &lt;a href=&quot;https://stackoverflow.com/questions/16116952/can-multithreading-be-implemented-on-a-single-processor-system&quot;&gt;Can multithreading be implemented on a single processor system?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;HowToGeek - &lt;a href=&quot;https://www.howtogeek.com/194756/cpu-basics-multiple-cpus-cores-and-hyper-threading-explained/&quot;&gt;CPU Basics: Multiple CPUs, Cores, and Hyper-Threading Explained&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Oracle.com - &lt;a href=&quot;https://docs.oracle.com/cd/E19205-01/820-0619/geojs/index.html&quot;&gt;1.2 What is a Data Race?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Jaka’s corner - &lt;a href=&quot;http://jakascorner.com/blog/2016/01/data-races.html&quot;&gt;Data race and mutex&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Thread_safety&quot;&gt;Thread safety&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Preshing on Programming - &lt;a href=&quot;https://preshing.com/20130618/atomic-vs-non-atomic-operations/&quot;&gt;Atomic vs. Non-Atomic Operations&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Wikipedia - &lt;a href=&quot;https://en.wikipedia.org/wiki/Green_threads&quot;&gt;Green threads&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;Stackoverflow - &lt;a href=&quot;https://stackoverflow.com/questions/617787/why-should-i-use-a-thread-vs-using-a-process&quot;&gt;Why should I use a thread vs. using a process?&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;本文译自https://www.internalpointers.com/post/gentle-introduction-multithreading，英文读者可直接阅读原文。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>“程序员”的成长之路</title>
                <link>https://www.reploop.org/blog/2020/01/share.html</link>
                <pubDate>Wed, 29 Jan 2020 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2020/01/share.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;本文系2017年11月25日“鸟哥”的题为《“程序员”程序员成长之路》的分享结合自身的理解整理而来。这个分享PPT如果硬要规个类别的话，那就是乔布斯或者老罗说相声的PPT的样子，一页上只有一行字，其他的全靠嘴上功夫，然而就这样随性讲了2个小时，过程中轻松愉快，也不乏启发思考的点，是小白个人比较喜欢的风格。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;分享环节&quot;&gt;分享环节&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;鸡汤有毒&quot;&gt;鸡汤有毒&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;开场白是鸡汤有毒，明确表达了很少做非技术类的分享。对待鸡汤应该持有的态度是评判性的，要有能力甄别信息。 过程中也是提出观点，让听众自己思考。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;要有野心并且要让其他人知道&quot;&gt;要有“野心”，并且要让其他人知道&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;这里的“野心”说的是你短期或长期的目标。每个人都有自己的“野心”，只是有些人表达出来了，而有些是羞于表达的。比如最实际的一个目标是你想不想1年后工资涨50%？我相信每个人心中都有过这个想法，你也可以把他确立为你的短期目标。等目标明确了之后，要让其他人知道。因为其他人往往不知道你想要什么，之后就为这个目标去努力。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;排除干扰&quot;&gt;排除干扰&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;每天困扰你的问题，也就是干扰项，要有意识、有目的、有手段的去消除。鸟哥本身对物质享受要求高一些，08年毕业后加入雅虎后月薪7000左右，但是租房就花了3000左右，头2个月还是挺好的，第三个月补交了前2个月的各种税和费之后，竟然不够交房租的了。核心部门核心业务3.4个月，目标明确的去了百度系统部，解决钱少的问题。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;毕业5年非常关键，干扰少，能迅速的提升。技术是一通百通的，学习思考的方法，而不是具体的技能。内向与外向：遇到挫折后自己静一静想办法解决的为内向，到处找人吐槽寻求帮助的为外向。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;舒适区对自己狠一些&quot;&gt;舒适区，对自己狠一些。&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;懒惰是天性，需要有目的的把自己往一个方向上逼。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;通过事提升人&quot;&gt;通过事提升人&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;认真对待每一件事，不管做什么事，要做完美。追求卓越之后，一定有提升。横向业务的人资源比较充足。业务线的人都是比较紧张的。鸟哥本人西交大计算机，然后国际关系学院。为了做鸡头走向php，国内没人做，差异化，走出了名头。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;建设影响力&quot;&gt;建设影响力&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;影响力决定了资源能不能向你靠拢，积极主动的去建设影响力。影响力：帮助了多少人决定了你的影响力。做的事情多，想问题的方面多，思考问题的角度多一些，所以成长快。鼓励大家多做分享，不要怕说错。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;为机会提早准备&quot;&gt;为机会提早准备&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;时刻学习。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;修身养性&quot;&gt;修身养性&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;教主原来是个死胖子，然后每天早上去健身，坚持了2年了。为了能够早上健身，还特意再健身房附近租了房子。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;问答环节&quot;&gt;问答环节&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;qlist qanda&quot;&gt; 
   &lt;ol&gt; 
    &lt;li&gt; &lt;p&gt;&lt;em&gt;如何看人工智能？&lt;/em&gt;&lt;/p&gt; &lt;p&gt;笑称：人工智能是人工智障。拐点：机器可以开始自我学习的时候。但是未必会出现，不确定。现在是人机交互和图像识别做的好，整体还是挺傻逼的。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;em&gt;精和广该如何选择？&lt;/em&gt;&lt;/p&gt; &lt;p&gt;精度和广度是矛盾的，二选一。先精以后，以后学习总结到一套抽象的认识，然后以这为根据地往广度拓宽会比较容易一些。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;em&gt;精英创业与草根创业&lt;/em&gt;&lt;/p&gt; &lt;p&gt;自己的定位清晰。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;em&gt;架构师的关注？&lt;/em&gt;&lt;/p&gt; &lt;p&gt;全面了解系统的各个组成，懂得权衡，引进业界优秀方案，找到对业务合适的系统组成方式。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;em&gt;大公司完善体系，如何提升？&lt;/em&gt;&lt;/p&gt; &lt;p&gt;核心点还是自己的目标要明确，明确了之后办法自然就有了。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;em&gt;副总裁与架构师怎么平衡的？&lt;/em&gt;&lt;/p&gt; &lt;p&gt;技术是乐趣，更喜欢程序员的称呼。做事是目的，想做的话什么事都能做好。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;em&gt;机会该不该主动争取的事情?&lt;/em&gt;&lt;/p&gt; &lt;p&gt;蝴蝶效应,一定要争取&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;em&gt;对语言的看法？&lt;/em&gt;&lt;/p&gt; &lt;p&gt;facebook开源具有玩票性质。需求是工具，重要的是解决问题的方法。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;em&gt;面试的时候提问一些题外话是不是需要了解的？&lt;/em&gt;&lt;/p&gt; &lt;p&gt;明确目标，不管是什么困难都迎难而上，面试让你不懂什么，想去就学习。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;em&gt;如何技术晋升？&lt;/em&gt;&lt;/p&gt; &lt;p&gt;业务复杂，解决方案，评审的时候看的是能力，而不是经验(做过什么)。主要说明遇到了什么问题(突出难点)，我的解决方案是什么(列举一些，要有对比，说明优劣)，最后取得了什么效果。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;em&gt;技术转管理的困惑？&lt;/em&gt;&lt;/p&gt; &lt;p&gt;团队的技术效能最大化，管理方法千人千面，自己摸索。自己的成就感来源要变。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;em&gt;百度的经历?&lt;/em&gt;&lt;/p&gt; &lt;p&gt;我一直努力让自己被更多人知道。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;&lt;em&gt;什么是牛人？&lt;/em&gt;&lt;/p&gt; &lt;p&gt;正真的牛人是解决问题的。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ol&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>视频的GC</title>
                <link>https://www.reploop.org/blog/2020/01/gc-in-video.html</link>
                <pubDate>Mon, 20 Jan 2020 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2020/01/gc-in-video.html</guid>
                <description>
                        &lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;很久以前，看闾丘露薇的文章说她每次出差回香港，都要到报刊亭“扫货”，收各种娱乐八卦小报回来看。以闾丘露薇报道的内容来臆测一下，她未必会对娱乐八卦感兴趣，为啥要看？为了跟同事信息同步，重回办公室后和大家有的聊。现在更是一个信息爆炸的时代，没有人能掌握周遭的全部信息，因此得有所取舍，才能真正掌握有价值的信息。不巧的是你“舍”的那部分可能就是别人“取”的那部分，那就得像闾丘露薇那样补回来，你才不脱节。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;进一步说我们需要一个在很短的时间内，了解故事梗概的服务。就像吃顿快餐一样，很快，但足以果腹。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;互联网上的“撕逼”大战，官员落马之后的“履历”等一样，大部分人是不会盯着电脑跟进展的，只需要第二天看一个“长微博”来梳理来龙去脉就可以了。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;对于视频行业来说，时下最流行的剧未必是你的菜，但是大家都在聊，必须得补回来！这顿快餐的吃法可能是回家之后开始看，一路“拖拖拖”，快进着浏览一遍。看视频还真是不如翻书方便。或者你去搜索故事梗概，快速浏览一遍，那样你就失去了画面。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;视频需要一个更快的快餐吃法，不需要“拖”，也不需要完全丢失她的味道。一个剧一般来讲都有几个主要演员，几条线同时铺开来讲故事。当然，主演的这条线就应该是主线了。只要抓住这条线看，你大概是不会错过绝大部分精彩的。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;此时就应该把人们吐槽的“神剪辑”可以拿来用一下。就是应用图像识别技术，在视频中找到所有该演员出现的镜头剪辑成一个小片，供你观看，再进一步，还可以利用语音识别技术，把所有提到某演员的地方也都找出来。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;这正是Java垃圾回收的思想Mark and Sweep，当然了，你如果特别讨厌一个角色，也可以定点清除；你只关心某个角色，也可以只看此角色的镜头，有点论坛时代的“只看楼主”的意思了。&lt;/p&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>香港开户经历</title>
                <link>https://www.reploop.org/blog/2020/01/bank-account-in-hk.html</link>
                <pubDate>Sun, 6 May 2018 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2020/01/bank-account-in-hk.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;香港金融中心，没有外汇管制，有个香港的账户方便很多。本文是个人亲身经历，介绍一下肉身到香港开户的过程。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;出行准备&quot;&gt;出行准备&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;去香港之前，已经打听过一些准备资料，最基本的有：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;olist arabic&quot;&gt; 
   &lt;ol class=&quot;arabic&quot;&gt; 
    &lt;li&gt; &lt;p&gt;身份证和港澳通行证。这个只要能去香港的话，基本都具备。需要注意的一点是大陆身份证也要携带，外资银行喜欢看上面的地址。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;地址证明。需要一个你能收到信的非公司地址证明。一般来说有以下几种地址：&lt;/p&gt; 
     &lt;div class=&quot;ulist&quot;&gt; 
      &lt;ul&gt; 
       &lt;li&gt; &lt;p&gt;身份证上的地址。大陆一般这个地址都是派出所地址，基本上没用。&lt;/p&gt; &lt;/li&gt; 
       &lt;li&gt; &lt;p&gt;水电缴费单，上面有个人名字的。我家的缴费单只写到门牌号，没有名字。按照渣打银行客户经理的话说，大陆是只管这个单元有人交水电费，而不管谁交。&lt;/p&gt; &lt;/li&gt; 
       &lt;li&gt; &lt;p&gt;信用卡账单地址。可能是唯一拿得出手的，有用的地址了。&lt;/p&gt; &lt;/li&gt; 
       &lt;li&gt; &lt;p&gt;保险单地址。如果有买保险的话，这个地址或许也可以用用。&lt;/p&gt; &lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/div&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;存款准备金。开户的时候一般银行都有最低存款额要求，不同的银行要求不同。另外，银行看账户的总资产，比如你买了20万的股票，10万的保险，虽然没有一分钱现金，但是你的总资产在30万了。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;银行流水单。用以证明你是有正当、稳定收入的。看一些介绍说有用，但是我这次没有用到。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ol&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;以上资料可能并不会全部用到，看银行具体要求和你遇到的客户经理了，多准备点总没有坏处。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;申请经历&quot;&gt;申请经历&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;在香港，当时的行程是在中环有一个下午的时段空闲。中环的银行也比较多，就开始转悠。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;渣打银行&quot;&gt;渣打银行&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;第一家去了渣打银行。进门取了个号，晃悠了一圈，逮着个大堂工作人员说我想开个户，工作人员的第一反馈是问我准备存多少钱进来，干什么。在大陆的时候看过一些介绍， 所以就打肿脸蛋充胖子，说按照外汇管制的限额，我可能一年内存30万进来用于投资理财。随后工作人员说渣打银行最低存款要求20万，我符合要求。随后介绍一位同事过来，算是和我重复、正式的聊了一下上面的问题。&lt;/p&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;OK, 准备资料（身份证，港澳通行证，地址证明）拿去复印的同时介绍了一位客户经理过来，到一个会议室继续聊，主要还是存多少钱和干什么的问题。 存多少钱没问题，但是我说的用于投资理财的用途则有点勉强了。由于监管变严格，&lt;strong&gt;为了防止洗钱，资金外逃等，现在大陆来香港开单纯的股票、基金账户不好审批&lt;/strong&gt;。因为大陆有渠道投资港股（没记错的话沪港通要50万才能用），理由不充分。但是香港的保险和大陆的有很大的不同，建议我同时买一份保险，就比较好审批。推荐了英国保诚的储蓄险种，我说要和家人再考虑考虑。不想让我留下一次被拒绝的记录，客户经理说等我考虑好了在帮忙提交申请， 同时，地址证明出了问题，外资银行不认可国内银行的账单地址，包括保险账单地址。他们最好的是身份证上的地址，其次是水电缴费单，有名字在上面的。所以我提供的地址证明全部没用了。期间也讨论过其他的方式，比如别的外资机构寄给我的东西，如果有地址的话也能用。第一次申请就此作罢。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;sect2&quot;&gt; 
   &lt;h3 id=&quot;中国银行香港&quot;&gt;中国银行(香港)&lt;/h3&gt; 
   &lt;div class=&quot;paragraph&quot;&gt; 
    &lt;p&gt;从渣打出来之后直接去了中国银行，过去的比较晚了，下午4点多到了之后拿了号码排队，银行五点以后就不允许进人了。中间就是等啊等，其实按照大陆的经验，排队的人倒是没几个，但是每个人办理业务的时间很长。到我办理的时候已经是下午六点了，当天的倒数第二位客户了。基本上很顺利，材料还是那些材料，20分钟不到就办理完成了。有意思的是说最低存款1万，但是也由于下班了，并没有要求我当场存款。所以就是没花钱开了个户口，但是没钱在里面是需要管理费的。&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;中国银行（香港）出来之后所有的银行都下班了，也算是完成了开户的目标。晚上和一位在香港生活10多年的朋友吃饭，聊到这个事情，建议海外第一个账户选择中资银行，等有了第一个户头以后，再到外资银行说，想把业务转过来，他们就很喜欢了。还有所谓的开户最低存款，只是为了保证账户是有效账户。只要你开了账户，不管里面钱多钱少，只是管理费的问题了。另外，开户用途大陆很多文章说要选择投资理财账户，之所以这样，是因为这种账户客户经理可以提成，所以比较推荐。但是其实只申请一个储蓄账户，什么附加功能都不需要的账户也是可以的。不过，香港存款利率是千分之几，相当的低，所以香港人一般都不会存款的，单纯的存款，由于有管理费的存在，你的钱会越来越少的。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
            <item>
                <title>Thrift的坑</title>
                <link>https://www.reploop.org/blog/2020/01/the-bad-of-thrift.html</link>
                <pubDate>Sat, 3 Jun 2017 00:00:00 +0800</pubDate>
                <guid isPermaLink="false">blog/2020/01/the-bad-of-thrift.html</guid>
                <description>
                        &lt;div id=&quot;preamble&quot;&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;quoteblock abstract&quot;&gt; 
   &lt;blockquote&gt;
     Thrift虽好，但是吹毛求疵的讲，可以更好。 
   &lt;/blockquote&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;Thrift作为一个经常拿来和Google的Protocol Buffers比较的二进制协议阵营中的重量级选手，我认为其最大的特点就是有个完整的RPC协议栈，而Protocol Buffers开源出来的版本基本上可以认为仅仅是个跨平台的数据序列化/反序列化的工具。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;imageblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;img src=&quot;https://www.reploop.org/blog/2020/01/images/Apache_Thrift_Architecture.png&quot; alt=&quot;Thrift结构图&quot;&gt; 
   &lt;/div&gt; 
   &lt;div class=&quot;title&quot;&gt;
    Figure 1. Thrift结构图, 来自Wikipedia
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;也是基于最大的理由，我们在RPC环境下选择了Thrift。但是在使用Thrift的过程中也逐渐发现她的一些不尽如我意的地方。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;集合里面不能有null值&quot;&gt;集合里面不能有null值&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;集合是指Thrift原生支持的list，set和map这三个容器类的数据结构。使用Java语言的话，集合里面不能有null值这点要特别注意。Thrift使用的Java的ArrayList，HashSet和HashMap这3个数据结构分别实现list，set和map。从Java的语义来讲，ArrayList里面是允许有null值的，HashMap的键（key）和值（value）都是允许有null值的，而HashSet内部是用了一个HashMap来实现的，同样也是允许有null值的。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;listingblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;// HashMap
Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
map.put(null, null);
assert(1 == map.size());

// HashSet
Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
set.add(null);
assert(1 == set.size());&lt;/code&gt;&lt;/pre&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;上面这段代码在Java语言范畴内是完全合法的，但是在Thrift里面，只要这些集合类里面混进了null值，而Thrift本身（libthrift）不做这方面的数据校验，就会导致客户端因为读不到预期的数据而报超时异常。所以写入的时候务必要对数据做非空的校验，从而避免这类异常的出现。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;集合中不建议直接用枚举类型&quot;&gt;集合中不建议直接用枚举类型&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;在Java语言中，枚举类型做Map的key是一个常用的做法，而且遇到枚举类型，基本上可以放心使用，而不用担心null值的。但是在Thrift环境下，为了避免枚举值（enum）扩展而带来的问题，枚举类型不要用在任何容器类集合里面，比如map，set和list。一旦这些集合类中出现enum类型，如果enum扩展了，增加了一个新值，那么就 &lt;strong&gt;需要所有的客户端先升级，代价比较大&lt;/strong&gt;。 这是因为一旦服务端先升级的话，客户端因为没有升级Schema而在读到这个新的枚举值的时候就会出现null值。这样的话，Map里面出现了null的key，相当于这个数据丢失了。从Java的角度来进一步讲，就会出现枚举属性为null的情况，这个会在业务代码中引起非常多的问题。为了避免这种潜在的问题，要确保枚举都用在struct中形成间接的关系而不能直接放入容器类集合中去。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;字符串不能压缩&quot;&gt;字符串不能压缩&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;实际上Thrift是有TCompactProtocol的，但是这个Protocol做的大部分工作是数值的编码工作以减少数据量。 &lt;strong&gt;但是实际业务中，往往字符串传输占了非常大的比例。针对字符串的压缩，Thrift并没有原生的支持&lt;/strong&gt;。自己扩展Protocol支持字符串压缩也不是很方面，这往往需要在Thrift协议之上在包装一个定制的协议。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;传输协议不支持动态探测&quot;&gt;传输协议不支持动态探测&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;Protocol使用的时候只能通过服务端与客户端开发人员协商约定来确定，一旦确定之后很难变更。也就是协议没有动态探测功能，任何一端使用新的Protocol的话，都将导致对等的端不能解析数据。如何你的系统在Thrift上跑了几年，数据存储了非常，那么要实现一个字符串压缩功能，不停服，不更新存量数据的情况下基本上无法做到，而这个代价是相当大的。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;不规范json序列化输出&quot;&gt;不规范JSON序列化输出&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;枚举值做key，序列化的时候适用枚举对应的数值，而不是字符串。这样用TSimpleJSONProtocol序列化就产生了不标准JSON。JSON里面的Key都要求是字符串，而不能出现数值。需要定制一个特殊的JSON序列化Protocol。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;没有header的支持&quot;&gt;没有Header的支持&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;我们开头也说了，Thrift有完整的协议栈。如果仅仅使用协议栈就能满足业务的话，这个应该也不是问题。但是一个实战中的RPC服务，一般来讲都会涉及一些用户认证，背压，限流，降级，熔断等等，更别说调用链分析这种业务了。没有Header的支持，基本上要做到以上功能，都是需要侵入业务API的。比如一个检查用户昵称是否被占用的服务, 业务相关的API设计成这样应该是比较实用的:&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;listingblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-thrift&quot; data-lang=&quot;thrift&quot;&gt;service UserService{
  bool checkNickname(1:string nickname);
}&lt;/code&gt;&lt;/pre&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这就没法携带更多的信息了。如果我们要做用户认证，侵入业务API的做法，一种可能的实现可能是这样的：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;listingblock&quot;&gt; 
   &lt;div class=&quot;content&quot;&gt; 
    &lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-thrift&quot; data-lang=&quot;thrift&quot;&gt;struct NickNameRequest {
  1: string nickname,
  2: string authUser,
}
service UserService{
  bool checkNickname(1:NickNameRequest request);
}&lt;/code&gt;&lt;/pre&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;这就对业务使用方不是特别方便。 那么如何让Thrift支持Header呢？可能的方案至少有2个：&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;olist arabic&quot;&gt; 
   &lt;ol class=&quot;arabic&quot;&gt; 
    &lt;li&gt; &lt;p&gt;根据Thrift支持service multiplexing的思路，在service name里面做文章。这个需要Thrift 0.9以上的版本。&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;根据Thrift解析数据的特点定制Protocol，善用FiledId为0和-1这些保留的值。&lt;/p&gt; &lt;/li&gt; 
   &lt;/ol&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;java类库代码质量不好&quot;&gt;Java类库代码质量不好&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;用静态代码分析工具分析一下Thrift的Java代码，结果往往是不忍直视。把这些问题归为编码规范的范畴也能说得过去，毕竟，能工作的代码，无论多么丑陋，他的核心价值并没有因此而减少。但是从可扩展的角度来考虑一下，基本上Thrift的Java代码质量是不太好的，基于他的二次开发扩展很难。毕竟Thrift的大部分代码是编译器自动生成的，也不需要人工维护。要扩展功能的时候，Java体系内可借助Thrift的metadata和反射来处理。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div class=&quot;sect1&quot;&gt; 
 &lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt; 
 &lt;div class=&quot;sectionbody&quot;&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;实际上，当前的RPC实现流行的做法使用netty做网络层，然后Thrift/Protocol Buffers用来描述数据结构以及序列化和反序列化数据。比如gRPC和armeria，基本上都抽象一个基本的Request和Response模型，然后使用分层的思路，或者类似Java语言中的Filter Chain模式来自由控制请求与响应，扩展性极强，可以和丰富的第三方类库整合。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;div class=&quot;paragraph&quot;&gt; 
   &lt;p&gt;如果现在要评估Thrift和Protocol Buffers用哪个，我的第一选择可能是Protocol Buffers了。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                </description>
            </item>
    </channel>
</rss>
