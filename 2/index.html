<!DOCTYPE html>
<html lang="zh_CN">
  <head>
    <meta charset="utf-8"/>
    <title>REPLoop</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="乔治">
    <meta name="keywords" content="REPL,REPLoop,George,乔治">
    <meta name="generator" content="JBake v2.7.0.1">
    <meta property=og:locale content=zh_CN>
    <!-- Le styles -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/asciidoctor.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/prettify.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="../img/favicon.svg">
    <script data-ad-client="ca-pub-2350040335860411" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../">REPLoop</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../index.html">博客</a></li>
            <li><a href="../archive.html">归档</a></li>
            <li><a href="../tags/index.html">标签</a></li>
            <li><a href="../about.html">关于</a></li>
            <li><a href="../feed.xml">订阅</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">
  		<a href="blog/2020/05/how-to-size-thread-pool.html"><h1>如何设置线程池的大小？</h1></a>
  		<p>
			<a href="/about.html"><strong>乔治</strong></a>于2020年05月04日
					<span class="badge badge-dark">多线程</span>
					<span class="badge badge-dark">线程池</span>
		</p>
  		<p><div id="preamble"> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>多核环境下，为了更好的资源利用率，多线程基本上算是一个常规武器了。 我们知道CPU是用来计算的，而计算所需要的外部数据则是交给独立的I/O系统处理的。CPU和I/O的特点就是一个快，一个慢，大约差 <a href="https://colin-scott.github.io/personal_website/research/interactive_latency.html">2～3个数量级</a>。所以为了不浪费快的资源，就把慢的事情交给独立的系统做，等慢的资源准备好了在通知快的资源(也叫 <strong>中断处理</strong>)。所以一旦发生CPU需要等待外部数据的时候，操作系统的调度系统就会暂时保存当前计算的寄存器状态，程序计数器等(也叫 <strong>上下文</strong>) ，让出CPU给其他的可调度的进程。 这个过程称为 <strong>上下文切换</strong>。一旦发生了 <strong>上下文切换</strong>，以 <strong>线程</strong> 统一进行计算与I/O传输的应用这时就是被 <strong>阻塞</strong> 了。为了提高CPU的利用率，应用层面就是使用多个线程来保证CPU有计算可执行，线程池就是这么产生了。 以下就是本文的核心问题，如果你要创建一个线程池，该怎么确定线程池的大小呢？可以肯定的是线程数也不是越多越好。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="线程池的大小">线程池的大小</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>关于线程池的大小，有两本非常有名的书中都有相关的论述。这两本书还都是Java生态里面重量级人物写的。分别看一下：</p> 
  </div> 
  <div class="sect2"> 
   <h3 id="java_concurrency_in_practice">Java Concurrency In Practice</h3> 
   <div class="quoteblock"> 
    <blockquote>
      For compute intensive tasks, an <em>N<sub>cpu</sub></em>-processor system usually achieves optimum utilization with a thread pool of <em>N<sub>cpu</sub></em>+1 threads. (Even compute intensive threads occasionally take a page fault or pause for some other reason, so an "extra" runnable thread prevents CPU cycles from going unused when this happens.) For tasks that also include I/O or other blocking operations, you want a larger pool, since not all of the threads will be schedulable at all times. In order to size the pool properly, you must estimate the ratio of waiting time to compute time for your tasks; this estimate need not be precise and can be obtained through profiling or instrumentation. Alternatively, the size of the thread pool can be tuned by running the application using several different pool sizes under a benchmark load and observing the level of CPU utilization. 
    </blockquote> 
    <div class="attribution">
      — Brian Göetz
     <br> <cite>Java Concurrency In Practice: p.107</cite> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>书中先给出如下一些定义:</p> 
   </div> 
   <div class="paragraph"> 
    <p><em>N<sub>cpu</sub></em> = CPU核心数,</p> 
   </div> 
   <div class="paragraph"> 
    <p><em>U<sub>cpu</sub> = 目标CPU的使用率，其中 \$0 &lt;=\$ _U<sub>cpu</sub></em> \$&lt;= 1\$,</p> 
   </div> 
   <div class="paragraph"> 
    <p>\$w\$ = CPU等待时间，</p> 
   </div> 
   <div class="paragraph"> 
    <p>\$c\$ = CPU计算时间，</p> 
   </div> 
   <div class="paragraph"> 
    <p>\$w/c\$ = CPU等待时间和计算时间的比率,</p> 
   </div> 
   <div class="paragraph"> 
    <p>然后就给出了能够使处理器保持在特定使用率的线程数最优公式： <em>N<sub>threads</sub></em> = <em>N<sub>cpu</sub></em> * <em>U<sub>cpu</sub></em> * (\$1 + w/c\$)</p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="programming_concurrency_on_the_jvm">Programming Concurrency on the JVM</h3> 
   <div class="quoteblock"> 
    <blockquote>
      If tasks spend 50 percent of the time being blocked, then the number of threads should be twice the number of available cores. If they spend less time being blocked—that is, they’re computation intensive—then we should have fewer threads but no less than the number of cores. If they spend more time being blocked—that is, they’re IO intensive—then we should have more threads, specifically, several multiples of the number of cores. 
    </blockquote> 
    <div class="attribution">
      — Venkat Subramaniam
     <br> <cite>Programming Concurrency on the JVM: p.16</cite> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>这本书里没有直接给出变量定义，而是用文字描述的。为了便于比较，这里也给出一些定义：</p> 
   </div> 
   <div class="paragraph"> 
    <p><em>N<sub>threads</sub></em> = 总的线程数，</p> 
   </div> 
   <div class="paragraph"> 
    <p><em>N<sub>cpu</sub></em> = 可用的CPU核心数，</p> 
   </div> 
   <div class="paragraph"> 
    <p><em>B<sub>c</sub></em> = 阻塞系数，介于0和1之间的。</p> 
   </div> 
   <div class="paragraph"> 
    <p>那么，就可以用如下的方式计算我们需要的线程数了： <em>N<sub>threads</sub></em> = <em>N<sub>cpu</sub></em> / (1 - <em>B<sub>c</sub></em>)</p> 
   </div> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="分析与结论">分析与结论</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>乍一看，两本书给出了2个不一样的公式，该如何取舍呢？</p> 
  </div> 
  <div class="paragraph"> 
   <p>假设CPU的使用率 <em>U<sub>cpu</sub></em> 是100%的情况下，也就是如果目标都是尽可能的利用CPU资源，其实这两个公式是一样的。 只要定义阻塞系数(blocking coefficient) = \$w/(w+c)\$，也就是阻塞系数为阻塞时间与整个CPU时间的占比。那么他们就是一个意思：定性的描述就是阻塞时间越多，就需要更多线程来保证CPU有活干。上面2个不同的公式则是定量的表达上述思路了。优化线程池的大小是想用最少的线程上下文切换(或代价)来做到最大的(或特定目标)CPU使用率。</p> 
  </div> 
  <div class="paragraph"> 
   <p>第2本书没有把目标CPU使用率放到公式里面，都包含在阻塞系数里面了。</p> 
  </div> 
 </div> 
</div></p>
  		<a href="blog/2020/05/dev-acronyms.html"><h1>码农工作中的缩写词</h1></a>
  		<p>
			<a href="/about.html"><strong>乔治</strong></a>于2020年04月04日
					<span class="badge badge-dark">缩写词</span>
		</p>
  		<p><div id="preamble"> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>码农工作中，如果经常看一些英文的文档，混迹于github上抄抄源代码，发发邮件交流的话，或者和早几年外企出来的人一起工作的话，可能经常能看到一些缩写词。不懂的人一脸懵逼，懂的人可能因为少打了几次键盘提高了效率而提前下班被领导白眼。 不过缩写词也就是习惯的问题，不是啥逼格的问题。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="常用缩写词">常用缩写词</h2> 
 <div class="sectionbody"> 
  <div class="dlist"> 
   <dl> 
    <dt class="hdlist1">
     RP
    </dt> 
    <dd> 
     <p>pull request, 两个不同的代码仓库之间的合并请求。在分布式源码管理系统出来之后才有的概念，就是让别人拉取代码仓库变化的意思。</p> 
    </dd> 
    <dt class="hdlist1">
     MR
    </dt> 
    <dd> 
     <p>merge request, 提交代码前的合并请求。为了控制代码质量，有些代码分支不允许直接提交。 MR一般发生在向一个受保护的分支提交代码并请求评审代码的意思。</p> 
    </dd> 
    <dt class="hdlist1">
     IMHO
    </dt> 
    <dd> 
     <p>In My Humble Opinion. 也就是以我之见，恕我直言的意思。一般情况下是用于提出不同意见的。</p> 
    </dd> 
    <dt class="hdlist1">
     TBD
    </dt> 
    <dd> 
     <p>to be done，未完待续。意思是说一项工作应该要做，但是还没有完成。好多开源项目的文档中经常会看到。</p> 
    </dd> 
    <dt class="hdlist1">
     WIP
    </dt> 
    <dd> 
     <p>work in process, 施工/设计/处理/工作中，指一项工作正在进行中，还没有完成。开源中的Pull Request如果特别大，要分多次合并的话，每个Pull Request都可以加上[WIP]，说明还有后续的合并请求。</p> 
    </dd> 
    <dt class="hdlist1">
     WTF
    </dt> 
    <dd> 
     <p>what the fuck，类似国骂"我艹"之类的，语气词，大概就是这是什么玩意的意思。代码注释中经常能看见WTF的身影，愤怒的程序员。</p> 
    </dd> 
    <dt class="hdlist1">
     FYI
    </dt> 
    <dd> 
     <p>for your information，供你参考。一般是想把一个信息同步给另一个人，请他知晓的意思。</p> 
    </dd> 
    <dt class="hdlist1">
     TL;DR
    </dt> 
    <dd> 
     <p>too long, don’t read，太长，别看，也就是长篇大论预警提示。一般是一个结论的详细说明，如果仅仅关注结论，不关心缘由的话可以直接跳过的。</p> 
    </dd> 
    <dt class="hdlist1">
     LGTM
    </dt> 
    <dd> 
     <p>looks good to me，看起来不错。代码评审中的同意的意思。</p> 
    </dd> 
    <dt class="hdlist1">
     PTAL
    </dt> 
    <dd> 
     <p>please take a look，请看一下我的提交。github上经常能看到，某个代码提交或者合并请求，需要某个人评审，就可以这么说。</p> 
    </dd> 
    <dt class="hdlist1">
     SGTM
    </dt> 
    <dd> 
     <p>sounds good to me，听起来不错。代码评审中的同意的意思，或者某项提议/设计方案不错的意思。</p> 
    </dd> 
    <dt class="hdlist1">
     RTFM
    </dt> 
    <dd> 
     <p>read the fucking manual, 先读一下手册。一般都是问题太简单，都写在手册里面了。</p> 
    </dd> 
    <dt class="hdlist1">
     STFW
    </dt> 
    <dd> 
     <p>search the fucking web, 先上网查一下。一般都是问题太简单，简单搜索就能找到答案。</p> 
    </dd> 
    <dt class="hdlist1">
     W/O
    </dt> 
    <dd> 
     <p>without, 经常在github的issue中看到w/o，勉强也可也算开发术语，w/o转化为without之后就简单了吧？</p> 
    </dd> 
   </dl> 
  </div> 
  <div class="paragraph"> 
   <p>暂时写这么多，后面遇到新的在补充。</p> 
  </div> 
 </div> 
</div></p>
  		<a href="blog/2020/04/nginx-location-matching-rules.html"><h1>nginx配置文件中的location匹配规则</h1></a>
  		<p>
			<a href="/about.html"><strong>乔治</strong></a>于2020年04月04日
					<span class="badge badge-dark">nginx</span>
					<span class="badge badge-dark">配置文件</span>
					<span class="badge badge-dark">优先级</span>
					<span class="badge badge-dark">优化</span>
					<span class="badge badge-dark">location</span>
		</p>
  		<p><div id="preamble"> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>在反向代理的场景下，nginx用的人很多。在使用nginx的过程中，除了常规的反向代理配置，还经常临时性的要封个请求，加个限速，跳转一下等是常有的事情。这些都和location的配置规则相关。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="location语法">location语法</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>location支持5种语法，分别为：</p> 
  </div> 
  <div class="listingblock"> 
   <div class="content"> 
    <pre>1. location =   /uri {}   #完整字符串匹配，优先级最高，发现匹配就停止
2. location ^~  /uri {}   #字符串前缀匹配，发现匹配就停止。这个不是正则匹配
3. location     /uri {}   #字符串前缀匹配，取最具体的那个匹配（the most specific match），可理解为最长匹配。这里即使是找到了匹配，也会继续执行后面的正则匹配。
4. location ~   /uri {}   #正则匹配,大小写敏感。按在配置文件中定义的顺序执行，发现匹配就停止（The first regular expression to match the query will stop the search））
5. location ~*  /uri {}   #同规则4(~)，区别就是正则匹配时大小写不敏感</pre> 
   </div> 
  </div> 
  <div class="paragraph"> 
   <p>“发现匹配就停止”的意思是匹配过程终止了，已经得到了匹配结果并提前返回了，不会在执行后面的匹配了。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="执行顺序">执行顺序</h2> 
 <div class="sectionbody"> 
  <div class="ulist"> 
   <ul> 
    <li> <p>执行完整字符串匹配。从1)开始搜索，如果1）找到匹配，则停止搜索；</p> </li> 
    <li> <p>执行字符串前缀匹配。执行2），3），目的是找到最具体的那个匹配。此过程不会停止整个匹配过程，完成后会继续执行正则匹配。唯一的例外是，如果location的操作是^~，只要发现匹配就停止搜索；</p> </li> 
    <li> <p>执行正则匹配。4），5），按照配置文件中出现的顺序挨个匹配，如果发现匹配则停止搜索；</p> </li> 
    <li> <p>相同规则内执行顺序是按照规则在配置文件中出现的顺序从上到下顺序执行的。</p> </li> 
   </ul> 
  </div> 
  <div class="paragraph"> 
   <p>一句话概括一下就是先执行完整字符串匹配，找到匹配就结束，没有找到匹配，就继续执行前缀和正则匹配，最后就是如果找到正则匹配，就用正则匹配结果，如果没有找到，就用前缀匹配的结果。当然，有一个例外。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="匹配结果">匹配结果</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>根据 <strong>执行顺序</strong> 节的解释，我们可以确定匹配结果的优先级是：<strong>完整字符串匹配</strong> &gt; <strong>^~前缀匹配</strong> &gt; <strong>正则匹配</strong> &gt; <strong>字符串前缀匹配</strong>。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="location优化建议">location优化建议</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>根据不同匹配的不同规则，</p> 
  </div> 
  <div class="ulist"> 
   <ul> 
    <li> <p>在确定的情况下优先使用完整字符串匹配（=），</p> </li> 
    <li> <p>接下来优先使用（^~）。</p> </li> 
    <li> <p>接下来就是正则匹配的location要合理排序，最常用，访问最多的要排到前面。</p> </li> 
    <li> <p>最后是少写不带操作符的字符串前缀匹配。也就是location语法中的3.原因是a)这个过程是在正则匹配之前执行的，为了找到最具体的匹配，应该是需要全部执行;b)它的结果优先级没有正则匹配的高，如果后来发现了正则匹配，此过程就没有意义了。</p> </li> 
   </ul> 
  </div> 
  <div class="paragraph"> 
   <p>同时应该注意的是正则匹配（4，5）是按照配置文件中出现的顺序挨个匹配，取第一个匹配的结果。如果顺序安排不当，会有覆盖的结果。比如：</p> 
  </div> 
  <div class="listingblock"> 
   <div class="content"> 
    <pre class="prettyprint highlight"><code data-lang="bash">location ~ /uri {}           <i class="conum" data-value="1"></i><b>(1)</b>
location ~ /uri/\d{1,}/ {}   <i class="conum" data-value="2"></i><b>(2)</b></code></pre> 
   </div> 
  </div> 
  <div class="paragraph"> 
   <p>这个配置文件，如果遇到 <strong>/uri/12345/</strong> 这个请求的时候，最后的匹配结果是uri &lt;1&gt;，而不是后者 &lt;2&gt;。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="参考">参考</h2> 
 <div class="sectionbody"> 
  <div class="ulist"> 
   <ul> 
    <li> <p>nginx.org - <a href="http://wiki.nginx.org/HttpCoreModule#location" class="bare">http://wiki.nginx.org/HttpCoreModule#location</a></p> </li> 
   </ul> 
  </div> 
 </div> 
</div></p>

	<hr />
	
	<p><a href="../archive.html">点击查看更多文章</a>.</p>

		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2020 | Mixed with <a href="http://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="http://jbake.org">JBake v2.7.0.1</a></p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../js/jquery-1.11.1.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/prettify.js"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
  </body>
</html>