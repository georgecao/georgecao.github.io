<!DOCTYPE html>
<html lang="zh_CN">
  <head>
    <meta charset="utf-8"/>
    <title>REPLoop</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="乔治">
    <meta name="keywords" content="REPL,REPLoop,George,乔治">
    <meta name="generator" content="JBake v2.7.0.4">
    <meta property=og:locale content=zh_CN>
    <!-- Le styles -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/asciidoctor.css" rel="stylesheet">
    <link href="css/base.css" rel="stylesheet">
    <link href="css/prettify.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="img/favicon.svg">
    <script data-ad-client="ca-pub-2350040335860411" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="">REPLoop</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="index.html">博客</a></li>
            <li><a href="archive.html">归档</a></li>
            <li><a href="tags/index.html">标签</a></li>
            <li><a href="about.html">关于</a></li>
            <li><a href="feed.xml">订阅</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">
  		<a href="blog/2021/11/languages-i-learned-those-years.html"><h1>这些年学过/用过的编程语言</h1></a>
  		<p>
			<a href="/about.html"><strong>乔治</strong></a>于2021年11月19日
					<span class="badge badge-dark">Java</span>
					<span class="badge badge-dark">Ruby</span>
					<span class="badge badge-dark">Lua</span>
					<span class="badge badge-dark">Swift</span>
					<span class="badge badge-dark">Clojure</span>
					<span class="badge badge-dark">Scala</span>
					<span class="badge badge-dark">Golang</span>
					<span class="badge badge-dark">Javascript</span>
					<span class="badge badge-dark">Shell</span>
					<span class="badge badge-dark">Kotlin</span>
					<span class="badge badge-dark">C</span>
					<span class="badge badge-dark">Python</span>
					<span class="badge badge-dark">编程语言</span>
		</p>
  		<p><div id="preamble"> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>计算机专业科班，工作10+年，一直没有停止过编程。从事的工作兜兜转转，刚好就碰到了好多编程语言，下面说说我和这些编程语言的缘分。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="缘分">缘分</h2> 
 <div class="sectionbody"> 
  <div class="sect2"> 
   <h3 id="java">Java</h3> 
   <div class="paragraph"> 
    <p>Java是工作之前做的项目用的语言，学习和实践都需要用到的。他也是我工作之后的主要语言。第一份工作去了搜狐，当时的面试官后来评价说当时的面试表现比有些毕业几年的人都好。（不是自吹，可能刚好蒙对了命题范围，我当然也有百度笔试不过的经历）。</p> 
   </div> 
   <div class="paragraph"> 
    <p>Java是我唯一不停的跟踪其发展，尝试新功能，保持刻意学习的语言。</p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="lua">Lua</h3> 
   <div class="paragraph"> 
    <p>Lua就比较巧儿，决定用之前还没写过一行Lua代码。当时面临的场景是有个业务涉及到一些规则频繁的变动，实现的时候是用后端Java服务来做的，所以更新就会稍微麻烦一点。当时使用的反向代理是nginx，一直想说写个nginx插件把这个事情做了。这样规则计算和流量型的nginx集合起来，还能提高机器资源利用率。后来就发现了Lua和nginx结合比较开发友好，比C语言省事多了。</p> 
   </div> 
   <div class="paragraph"> 
    <p>想清楚之后就可以学习Lua，真的是从Reading The Fucking Manual开始的，然后看了几本电子书，边看边写的。最后写出来的是一个Lua+MongoDB操作的规则计算引擎，每天服务1+亿人。</p> 
   </div> 
   <div class="paragraph"> 
    <p>只可惜，后来想想这种越是灵活的东西，越是对用户不友好，学习成本高，面向一般人员的UI不好做，只能给程序员使用了。</p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="javascript">Javascript</h3> 
   <div class="paragraph"> 
    <p>Javascript我想Web开发的人很早的时候就接触了。 说几个古老的技术大概就理解了：ASP，JSP，jQuery，Ajax等。直到后来前后端分离之后，Javascript已然是最火热的语言之一了。大体上就是这些年后端造的轮子都会用Javascript再造一遍的意思。</p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="ruby">Ruby</h3> 
   <div class="paragraph"> 
    <p>Ruby是被迫学习的。面临的情况是团队不得已要优化，结果就是人走了，项目还得运行迭代。 刚开始看着源代码头大，然后就是看官网的语言设计原则，找了4，5本书快速看一遍，逐渐适应了另一种风格的语言，然后就逐渐的看明白了并且开始写bug了。</p> 
   </div> 
   <div class="paragraph"> 
    <p>一段时间被Ruby惊艳到了，觉得Ruby大概是CRUD工程师很好的选择，对于创业公司来讲，撸一个MVP是分分钟的事情。只可惜人才供给少，一般公司不敢入Ruby的坑吧。</p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="golang">Golang</h3> 
   <div class="paragraph"> 
    <p>Golang是公司买了一个系统，这个系统就是Golang写的。我要负责接收这个系统。听说过『Google出品，必属精品』的话，那就能想到Golang的新闻或者文章很多，还有很多拿他和Java做对比。这个项目不仅仅是一个业务系统，还涉及到算法。就这样我就开始从听过过Golang的人，到开始维护Golang版本的维特比，DFS与剪枝等算法。</p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="clojure">Clojure</h3> 
   <div class="paragraph"> 
    <p>Clojure语言是用Storm流式计算系统的时候碰到的。当时Storm非常热门，但是其核心代码是用Clojure写的。有些行为不理解的时候，最真实的答案就再源代码里面。所以就必须去理解，去调试，去验证。Clojure只能是远观，因为没有写部署到生产环境的Clojure代码。写Clojure代码，大概有一种手动构建抽象语法树的意思(AST)。</p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="scala">Scala</h3> 
   <div class="paragraph"> 
    <p>JVM生态中的函数式编程，出来的很早，加上当时Twitter公司的很多开源项目就用Scala写的，当时所在的公司里面也有项目在用。也仅仅是浏览过几本书。</p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="shell">Shell</h3> 
   <div class="paragraph"> 
    <p>工作大部分时间都是面向服务端的而且需要自己运维机器，所有命令行工具就必须要掌握。所以统计脚本，写过服务启动、停止的脚本，写过监控的脚本。有很多问题用脚本验证一下也很快。</p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="swiftobject_c">Swift/Object-C</h3> 
   <div class="paragraph"> 
    <p>也是团队优化项目不优化的情况下，开始维护iOS的APP。维护的过程中做一些必要的学习。</p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="kotlin">Kotlin</h3> 
   <div class="paragraph"> 
    <p>机缘巧合，不得不开始写Android的APP了。刚开始用Java，团队里面的主力Android开发，也是一个好学的人。把Java代码逐步的都翻译为Kotlin了，也就依葫芦画瓢的开始学习Kotlin了。Java和Kotlin是两种思路，时不时的交错，写出来的代码两边都不像。就这样也算是半个主力，短时间内撸出来一个APP。</p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="c">C</h3> 
   <div class="paragraph"> 
    <p>C语言除了学校里学过之后，工作中基本上和C打交道都是因为nginx。曾经和同事一起调试一个二分算法边界处理不严谨带来的偶发(数据相关)死循环的问题，连续debug了nginx好几天。</p> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="python">Python</h3> 
   <div class="paragraph"> 
    <p>Python大部分情况下是shell脚本搞不定了，就用Python来写写。谈不上会写Python，也没有经历过大型生产环境的项目。只能是放本字典再身边，用的时候翻字典，开卷考试那种。</p> 
   </div> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="如何学习">如何学习</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>从语言到工程应用，学习的过程基本上就是围绕着系统的生命周期来。</p> 
  </div> 
  <div class="dlist"> 
   <dl> 
    <dt class="hdlist1">
     语言与代码 
    </dt> 
    <dd> 
     <p>见过的编程语言多了之后，学习的过程大概就不会重点放在语法的部分，而是着重要了解语言的设计思路，语言的特性。把这个理解透彻了，后面会事半功倍的。一上来就着急开始写代码，不停的遇到拦路虎，这时候就不停的搜索以解决问题。这就变成了所谓的『面向搜索引擎』的编程。等你静下心来回头看，每个问题的解决办法都透露着语言的哲学。 这个阶段我一般是找3+本书，都快速浏览一遍，然后把符合自己胃口的书再精读一下。对于有经验的程序员，我是相信『21天学会编程』的。</p> 
    </dd> 
    <dt class="hdlist1">
     模块化 
    </dt> 
    <dd> 
     <p>大点的项目都是多人协作共同开发，然后代码的组织方式就很重要。有时候觉得语言很简单，但是项目代码确很庞大。所以要对语言写成的文件，命名空间，类/函数，代码块，作用域等特别关注一下，这些东西是模块化中最基本的东西。</p> 
    </dd> 
    <dt class="hdlist1">
     中间件 
    </dt> 
    <dd> 
     <p>每个语言大概都有几个应用广泛的中间件，比如Java的Spring, Ruby的Rails等等。这也是要重点关注的地方，大部分项目都离不开这些中间件。</p> 
    </dd> 
    <dt class="hdlist1">
     数据库 
    </dt> 
    <dd> 
     <p>计算机程序是算法+数据组成的，也就是code+data。只要涉及数据，大概率是要用到数据库。语言生态对数据库的支持也很重要。Ruby生态的ActiveRecord所应用的Association Model对简单应用开发效率是非常大的提升。</p> 
    </dd> 
    <dt class="hdlist1">
     依赖管理 
    </dt> 
    <dd> 
     <p>大项目都需要有依赖管理，工具就要有个必要的了解。尤其是碰到依赖冲突，多版本，找不到的资源的情况下。 开源的语境下，这也是想快速应用开源的代码要掌握的工具。</p> 
    </dd> 
    <dt class="hdlist1">
     构建工具 
    </dt> 
    <dd> 
     <p>构建工具大部分开发者不需要关注，把源代码打包成可以在服务器或者应用容器内跑起来的程序，每个语言都提供对应的编译器。这里想强调的是持续构建，就是程序员只需要提交代码，后面的构建都不需要太多参与，解放程序员。</p> 
    </dd> 
    <dt class="hdlist1">
     部署工具 
    </dt> 
    <dd> 
     <p>把打包好的程序放到服务器上并且跑起来，这是部署工具要解决的问题。这部分可以是『人工智能』的手动用scp，ftp之类的工具放上去或者下载下来，然后用命令行来启动，小小作坊大概就是这样的了。再面对的机器数，应用数，应用类型，运维不同的情况下需要一个稳定的可扩展的工具帮助团队做部署。</p> 
    </dd> 
    <dt class="hdlist1">
     运维 
    </dt> 
    <dd> 
     <p>这部分设计监控，报警，修复，扩容，缩容，测试，性能，安全等等方面的东西。 程序是跑到计算机中的，所以对他赖以生存的环境是非常有必要了解的。也就是对操作系统，网络，数据库原理，安全加密，协议，标准，内存，CPU，磁盘等等方面都要有一定的了解，学无止境。</p> 
    </dd> 
   </dl> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="总结">总结</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>常有争论，谁是世界上最好的编程语言？我的答案是没有最好，只有最适合。也就是那句话：抛开场景谈功能都是耍流氓。每个语言都有其最佳应用场景，单纯的对比语言，首先就是评判标准都不统一，不一致，得出的结论也就没啥实际意义。</p> 
  </div> 
  <div class="paragraph"> 
   <p>还有一类问题，是我要不要学习某某语言？反过来看这可能不是你决定的，是事情决定的。当然你要是对某某语言特别有兴趣，那就自己学就好了。如果语言只是吃饭讨生活的工具，那就遇到什么样子的问题，准备最合适解决该问题的工具吧。</p> 
  </div> 
  <div class="paragraph"> 
   <p>最后，也经常听到有人接我不会某某语言，解决不了某某问题。 这就是问题还不够要命，职责还不够明确。职场上要不想办法解决了，要不就换一个坑位吧。作为程序员，以我不会某某语言为由，在我看来大概也不可能是一个优秀的工程师了，持续学习很重要。</p> 
  </div> 
 </div> 
</div></p>
  		<a href="blog/2021/10/service-topology.html"><h1>服务拓扑</h1></a>
  		<p>
			<a href="/about.html"><strong>乔治</strong></a>于2021年10月16日
					<span class="badge badge-dark">服务拓扑</span>
					<span class="badge badge-dark">服务发现</span>
		</p>
  		<p><div id="preamble"> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>使用服务器部署服务的时候，各个服务之间的依赖关系通常是需要额外的工作来维护的。比如有一个MySQL数据库，在典型的运维场景，你想知道哪些应用依赖他就比较费劲，尤其是在一个变换频繁的团队中是需要一个统筹来管理的。 开源项目 <a href="https://github.com/reploop/reploop-topology">reploop-topology</a>的目的就是快速发现服务拓扑，其基本假设是一台机器提供服务必须要监听服务端口，并且建立网络连接。这是典型的分布式场景下通过网络连接起来的多机器之间的交互方式。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="拓扑">拓扑</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>主要利用 <code>lsof</code> 与 <code>ps</code> 命令获取主机上的监听的端口与服务进程。 需要在目标机器上执行如下命令：</p> 
  </div> 
  <div class="listingblock"> 
   <div class="content"> 
    <pre class="highlight"><code class="language-shell script" data-lang="shell script">sudo lsof -i 4 -nPR;
sudo ps -ef;</code></pre> 
   </div> 
  </div> 
  <div class="paragraph"> 
   <p><code>lsof</code> 命令获取机器上的所有网络连接，其中也包括了本地监听的端口信息，同时利用 <code>ps</code> 取得机器上的所有的服务进程。接着通过 <code>lsof</code> 和 <code>ps</code> 的输出结果中的相同的 <strong>pid</strong> 可以将网络连接归属到同一个服务进程，并且发现了进程之间的依赖关系。 接着将服务进程通过启动命令归属到同一个应用服务，这样就通过网络连接建立起此连接两端对应的服务之间的连接关系。</p> 
  </div> 
  <div class="paragraph"> 
   <p>一个网络连接，我们经常用5元组来唯一表示: (Source IP, Source Port, Destination IP, Destination Port, Protocol)。这就是源地址IP:Port，目的地址IP:Port ，以及相应的网络协议。下面就开始从基础的名词开始构建服务拓扑。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="名词">名词</h2> 
 <div class="sectionbody"> 
  <div class="dlist"> 
   <dl> 
    <dt class="hdlist1">
     IP
    </dt> 
    <dd> 
     <p>IP地址，每个网卡(NIC)有一个IP地址，并且在其子网内是唯一的。</p> 
    </dd> 
    <dt class="hdlist1">
     Port
    </dt> 
    <dd> 
     <p>网络端口，对于TCP协议，每个机器上是唯一的，同一时间不能被多个应用复用。有些端口是临时端口，可也就是只会出现一次的那种，处理的时候要注意。根据协议不同，有可能是TCP或者UDP协议。 TCP和UDP可以公用同一个端口，比如DNS服务可以同时绑定tcp/53和udp/53端口。 对于UDP的来说，一个端口可以同时被多个不同的应用绑定。</p> 
    </dd> 
    <dt class="hdlist1">
     Process
    </dt> 
    <dd> 
     <p>服务进程, 通过服务主入口区分不同的进程。也就是启动命令与main函数的命名空间。</p> 
    </dd> 
    <dt class="hdlist1">
     Server
    </dt> 
    <dd> 
     <p>机器，物理上的一台机器或者虚拟机。每台机器可以有多个网卡(NIC)，也就是多个IP。</p> 
    </dd> 
    <dt class="hdlist1">
     Server Port
    </dt> 
    <dd> 
     <p>服务器端口，一个服务的基本服务形式，一个服务上监听一个服务端口。 这里用(服务器:端口)取代通常理解的(IP:PORT)的形式，来处理一台机器上多网卡的情况。</p> 
    </dd> 
    <dt class="hdlist1">
     Service
    </dt> 
    <dd> 
     <p>应用服务，应用层面的服务，不考虑部署结构的应用服务。 这里需要注意的是一个服务可以仅仅作为请求的发起方(client模式)，从而不监听任何服务器端口。</p> 
    </dd> 
   </dl> 
  </div> 
  <div class="paragraph"> 
   <div class="title">
    ER图
   </div> 
   <p><span class="image"><img src="https://www.reploop.org/blog/2021/10/images/relation.svg" alt="ER图"></span></p> 
  </div> 
  <div class="paragraph"> 
   <p>通过lsof输出的网络连接IP:PORT→IP:PORT最终建立起Service之前的拓扑关系。</p> 
  </div> 
  <div class="paragraph"> 
   <div class="title">
    服务拓扑
   </div> 
   <p><span class="image"><img src="https://www.reploop.org/blog/2021/10/images/service.svg" alt="服务拓扑"></span></p> 
  </div> 
  <div class="paragraph"> 
   <p>这里也可以看出，通常一个服务既可以作为客户端依赖其他服务，也可以作为服务器提供服务。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="ip地址处理">IP地址处理</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>在一个服务器上监听一个端口，通常有几种写法：</p> 
  </div> 
  <div class="ulist"> 
   <ul> 
    <li> <p>*:Port, 监听所有网卡端口，也就是机器上的所有IP都可以访问这个端口。</p> </li> 
    <li> <p>0.0.0.0:Port, 监听IPv4的端口，</p> </li> 
   </ul> 
  </div> 
  <div class="paragraph"> 
   <p>以及本地回环地址127.0.0.1。 这些地址都将会处理为具体的IP地址。 具体是首先会通过 <code>lsof</code> 的输出结果中汇总出有连接建立的所有本地IP地址，然后用这些IP地址来替换上面出现的特殊形式的IP地址。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="process关系">Process关系</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>Linux服务器上的每个Process都有两个id，分别是PID与PPID。同一时刻服务器上的所有PID是不重复的，但是已经消亡的进程PID后面是可以重复被利用的。</p> 
  </div> 
  <div class="paragraph"> 
   <p>Linux下进程之间是一个树的关系，一个进程通过PPID指向其父进程。这点在处理 <code>lsof</code> 的输出时很重要，因为一个进程本身可以监听端口，也可以让子进程去监听端口提供服务。比如一些守护进程做的事就是其他真正的服务子进程去服务，自己则是一直监控着子进程的健康状态。 但是所有的子进程都应该看作一个服务进程来处理。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="缺点">缺点</h2> 
 <div class="sectionbody"> 
  <div class="dlist"> 
   <dl> 
    <dt class="hdlist1">
     短连接场景 
    </dt> 
    <dd> 
     <p>lsof运行的时机很重要，可能采集不到或者不全。</p> 
    </dd> 
    <dt class="hdlist1">
     定时任务 
    </dt> 
    <dd> 
     <p>同样也是lsof的运行时机很重要，可能采集不到或者不全。</p> 
    </dd> 
    <dt class="hdlist1">
     外部服务 
    </dt> 
    <dd> 
     <p>第三方服务识别需要提前标注。此部分针对的是机器不能登陆的情况下，获取不到具体信息的情况，都归类为外部第三方服务。 如果有用到Aliyun的话，可以结合Aliyun的Open API，识别出阿里云上的SLB，数据库等资源，使得整个拓扑更清晰。</p> 
    </dd> 
    <dt class="hdlist1">
     多进程与进程管理 
    </dt> 
    <dd> 
     <p>通过Linux系统进程管理与监控工具启动的服务，真正服务的是子进程，这个影响服务的识别。</p> 
    </dd> 
   </dl> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="应用场景">应用场景</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>以下是一些典型的应用场景：</p> 
  </div> 
  <div class="dlist"> 
   <dl> 
    <dt class="hdlist1">
     发现空闲机器
    </dt> 
    <dd> 
     <p>机器上没有服务进程的话，可以认为机器是空闲的。或者可以辅以其他信息识别空闲机器。</p> 
    </dd> 
    <dt class="hdlist1">
     理解服务拓扑
    </dt> 
    <dd> 
     <p>理解服务之间的调用依赖关系。在抄抄代码的开发模式下，可能会无意引入不必要的服务。</p> 
    </dd> 
    <dt class="hdlist1">
     识别意外服务
    </dt> 
    <dd> 
     <p>一般应用服务非常好理解，但是这些服务所依赖的辅助服务，经常被忽略。比如读写文件系统，日志监控服务等。</p> 
    </dd> 
   </dl> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="结论">结论</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>在微服务体系下，调用链是必备的。通过他也是可以画出服务拓扑关系的。也就不需要这么麻烦了。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="参考">参考</h2> 
 <div class="sectionbody"> 
  <div class="ulist"> 
   <ul> 
    <li> <p>The SO_REUSEPORT socket option, <a href="https://lwn.net/Articles/542629/" class="bare">https://lwn.net/Articles/542629/</a></p> </li> 
    <li> <p>reploop-topology, <a href="https://github.com/reploop/reploop-topology" class="bare">https://github.com/reploop/reploop-topology</a></p> </li> 
   </ul> 
  </div> 
 </div> 
</div></p>
  		<a href="blog/2021/09/maven-deps.html"><h1>Maven依赖管理理解</h1></a>
  		<p>
			<a href="/about.html"><strong>乔治</strong></a>于2021年09月24日
					<span class="badge badge-dark">maven</span>
					<span class="badge badge-dark">dependency</span>
					<span class="badge badge-dark">bom</span>
		</p>
  		<p><div id="preamble"> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>根据 <a href="https://www.jrebel.com/resources/java-developer-productivity-report-2021">JRebel 2021 Java Developer Productivity Report</a> ，Java项目构建工具中第一名的Maven占了67%，第二名的Gradle是20%。所以理解和掌握Maven是非常必要的。</p> 
  </div> 
  <div class="paragraph"> 
   <p>现在稍微大一点的Java项目都会涉及到bom和module，然后经过在pom.xml中的parent和dependency节点的组合之后，很方便的管理了。 不过也很容易造成模块或者依赖类库版本的冲突。而且这种问题一般编译期间不容易发现，到了运行期间就会出这种依赖的问题。遇到依赖的类库不符合预期的时候，我们一般就会问2个问题：</p> 
  </div> 
  <div class="ulist"> 
   <ul> 
    <li> <p>怎么引入的这个类库？</p> </li> 
    <li> <p>为什么选择了这个版本？</p> </li> 
   </ul> 
  </div> 
  <div class="paragraph"> 
   <p>为了回答这两个问题，我们先从介绍Maven开始。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="bom">BOM</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>BOM(Bill Of Materials)实质上就是一个特别的POM，在这个POM中集中的定义项目的依赖和管理和更新他们版本。这个就把管理和更新依赖及其版本的职责集中到一处统一管理、测试以及发布，其他项目只要依赖这个POM就省去了每个人都要考虑使用那个依赖的那个版本的问题。</p> 
  </div> 
  <div class="paragraph"> 
   <p>BOM一般有两种使用方式，</p> 
  </div> 
  <div class="ulist"> 
   <ul> 
    <li> <p>一种是直接通过pom.xml中的parent节点继承，一个项目只能有一个parent，这种常见的是一个组织内部自定义的BOM。</p> </li> 
   </ul> 
  </div> 
  <div class="listingblock"> 
   <div class="content"> 
    <pre class="highlight"><code class="language-xml" data-lang="xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
    &lt;version&gt;2.5.4&lt;/version&gt;
    &lt;relativePath/&gt;
&lt;/parent&gt;</code></pre> 
   </div> 
  </div> 
  <div class="ulist"> 
   <ul> 
    <li> <p>另一种方式是在pom.xml中的dependency management中使用import pom的方式引入。 这个没有数量的限制，常见的第三方类库都可以通过这种方式管理。</p> </li> 
   </ul> 
  </div> 
  <div class="listingblock"> 
   <div class="content"> 
    <pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
        &lt;version&gt;2.5.4&lt;/version&gt;
        &lt;type&gt;pom&lt;/type&gt; <i class="conum" data-value="1"></i><b>(1)</b>
        &lt;scope&gt;import&lt;/scope&gt; <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;/dependency&gt;
&lt;/dependencyManagement&gt;</code></pre> 
   </div> 
  </div> 
  <div class="colist arabic"> 
   <table> 
    <tbody>
     <tr> 
      <td><i class="conum" data-value="1"></i><b>1</b></td> 
      <td>type指定为pom</td> 
     </tr> 
     <tr> 
      <td><i class="conum" data-value="2"></i><b>2</b></td> 
      <td>scope指定为import</td> 
     </tr> 
    </tbody>
   </table> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="继承parent">继承(Parent)</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>pom.xml中声明parent节点之后，就是当前项目pom会继承指定的parent节点中的项目。 所谓的继承，也没啥特别的，其实就是一个把父项目中内容拷贝合并到子项目中的意思。只不过在拷贝合并的过程中，子项目中的元素会覆盖(overwrite)父项目中的相同元素。 而且一个项目只能有一个parent项目，这是不是和Java语言中的类的单继承机制很像？</p> 
  </div> 
  <div class="paragraph"> 
   <p>所以maven编译的时候就是直接递归的把当前项目的所有父项目的pom.xml内容依次拷贝到子项目的pom.xml文件中，同时在这个拷贝合并的过程中应用上面的覆盖原则。 之后就生成了一个effective pom，效果相当于执行如下命令：</p> 
  </div> 
  <div class="listingblock"> 
   <div class="content"> 
    <pre class="highlight"><code class="language-shell script" data-lang="shell script">mvn help:effective-pom</code></pre> 
   </div> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="传递依赖transitive_dependencies">传递依赖(Transitive Dependencies)</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>传递依赖是说当前项目能够自动的把它依赖的类库的依赖引入过来。这样就省去了当前项目重复的逐个申明依赖的类库。</p> 
  </div> 
  <div class="paragraph"> 
   <p>假设有A项目申明了依赖B，而项目B申明了依赖C，D和E：</p> 
  </div> 
  <div class="imageblock"> 
   <div class="content"> 
    <img src="https://www.reploop.org/blog/2021/09/images/deps.svg" alt="A只申明了依赖B"> 
   </div> 
   <div class="title">
    Figure 1. A只申明了依赖B
   </div> 
  </div> 
  <div class="paragraph"> 
   <p>应用依赖传递之后，项目A实际上是依赖的B，C，D和E。效果等同下图：</p> 
  </div> 
  <div class="imageblock"> 
   <div class="content"> 
    <img src="https://www.reploop.org/blog/2021/09/images/deps-resolved.svg" alt="A实际上依赖了B，C，D，E"> 
   </div> 
   <div class="title">
    Figure 2. A实际上依赖了B，C，D，E
   </div> 
  </div> 
  <div class="paragraph"> 
   <p>这里面还涉及一个依赖的scope的问题，会影响依赖的传递，先不细说了，也不影响理解依赖的传递。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="依赖管理dependency_management">依赖管理(Dependency Management)</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>BOM中dependencyManagement元素就是集中定义依赖及其版本的地方，这样使用这个BOM的项目就不需要在单独定义版本了。而且dependencyManagement元素中的依赖只有用到了才起作用，也就是出现在dependencies节点中的时候，这时候就不用指定依赖的版本号了。</p> 
  </div> 
  <div class="quoteblock"> 
   <blockquote>
     Dependency management - this allows project authors to directly specify the versions of artifacts to be used when they are encountered in transitive dependencies or in dependencies where no version has been specified. In the example in the preceding section a dependency was directly added to A even though it is not directly used by A. Instead, A can include D as a dependency in its dependencyManagement section and directly control which version of D is used when, or if, it is ever referenced. 
   </blockquote> 
   <div class="attribution">
     — Maven
    <br> <cite>https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html</cite> 
   </div> 
  </div> 
  <div class="paragraph"> 
   <p>dependencyManagement元素中定义的依赖及其版本是能够直接控制传递依赖和没有指定版本的依赖的版本的。但是如果是当前项目的pom.xml的dependencies节点中直接申明的带版本的依赖，则不受dependencyManagement中定义的版本控制。</p> 
  </div> 
  <div class="paragraph"> 
   <p>假如项目A中直接依赖了B，通过B间接依赖的2.0版本的C，如下图：</p> 
  </div> 
  <div class="imageblock"> 
   <div class="content"> 
    <img src="https://www.reploop.org/blog/2021/09/images/deps-version.svg" alt="A项目的传递依赖C(2.0)"> 
   </div> 
   <div class="title">
    Figure 3. A项目的传递依赖C(2.0)
   </div> 
  </div> 
  <div class="paragraph"> 
   <p>这时候如果 dependencyManagement元素中直接定义了1.0版本的依赖C，那最终A项目依赖的C是1.0版本的：</p> 
  </div> 
  <div class="imageblock"> 
   <div class="content"> 
    <img src="https://www.reploop.org/blog/2021/09/images/deps-version-resolved.svg" alt="A项目的实际依赖C(1.0)"> 
   </div> 
   <div class="title">
    Figure 4. A项目的实际依赖C(1.0)
   </div> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="依赖协调dependency_mediation">依赖协调(Dependency Mediation)</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>我们知道一个依赖可以通一个三元组(groupId:artifactId:version)来确定, 其中的groupId:artifactId组合用来区分不同的依赖，同一个依赖则是用version来确定用哪一个。</p> 
  </div> 
  <div class="paragraph"> 
   <p>这里面的version没有具体的规范，就是一个字符串, 所以Maven不知道同一个依赖的不同版本哪个是新的，那个是旧的。因此有多个版本的时候不是选用最新的版本，而是选当前项目的依赖中最近的声明版本(nearest definition)。</p> 
  </div> 
  <div class="quoteblock"> 
   <blockquote>
     Dependency mediation - this determines what version of an artifact will be chosen when multiple versions are encountered as dependencies. Maven picks the "nearest definition". That is, it uses the version of the closest dependency to your project in the tree of dependencies. You can always guarantee a version by declaring it explicitly in your project’s POM. Note that if two dependency versions are at the same depth in the dependency tree, the first declaration wins. 
   </blockquote> 
   <div class="attribution">
     — Maven
    <br> <cite>https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html</cite> 
   </div> 
  </div> 
  <div class="paragraph"> 
   <p>把当前项目的依赖组织成一棵树, 姑且称之为依赖树，寻找最近申明的依赖的过程就是广度优先(BFS)遍历这棵树，遇到遍历过的依赖就剪枝，删除包含遍历过的节点以及其子树。这样就是在依赖树中寻找到当前项目的最短路径的依赖，而相同层级的话，也优先使用了最先遇到的。这里面也隐含了依赖申明顺序的问题，稍后说明。</p> 
  </div> 
  <div class="paragraph"> 
   <p>假设项目A的依赖关系如下图，对于D这个依赖来讲，应用nearest definition原则，Maven最终会选用的版本是D(2.0)。</p> 
  </div> 
  <div class="imageblock"> 
   <div class="content"> 
    <img src="https://www.reploop.org/blog/2021/09/images/deps-version-tree.svg" alt="项目A的依赖树"> 
   </div> 
   <div class="title">
    Figure 5. 项目A的依赖树
   </div> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="依赖优先级">依赖优先级</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>整个依赖管理中的优先级从高到低依次如下：</p> 
  </div> 
  <div class="olist arabic"> 
   <ol class="arabic"> 
    <li> <p>项目的dependencies中直接声明的依赖及其版本，一般同一个项目中不会申明相同依赖的不同版本，如果出现的话，优先使用先申明的依赖；</p> </li> 
    <li> <p>parent项目的dependencies节点中申明的依赖及其版本(参考上面的继承)；</p> </li> 
    <li> <p>import pom中申明的依赖及其版本，import pom的顺序很关键，如有依赖有版本冲突，按照声明的顺序依次使用；</p> </li> 
    <li> <p>当前项目的间接传递依赖及其版本。</p> </li> 
   </ol> 
  </div> 
  <div class="paragraph"> 
   <p>总结下来就是不同优先级的按照从高到低的优先级，相同优先级的按照他们的申明顺序从上到下(pom.xml文件解析顺序，也就是依赖申明顺序)。</p> 
  </div> 
  <div class="paragraph"> 
   <p>按照这个优先级，如果你发现有依赖的版本不符合预期，则可以通过这个优先级顺序在合适的地方直接申明想要的依赖就可以了。常见的我们就会直接在当前项目的pom.xml中直接申明一下需要使用的版本就可以了。</p> 
  </div> 
  <div class="paragraph"> 
   <p>这个优先级以及顺序，也是构建依赖树的优先级和顺序。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="常用排查命令">常用排查命令</h2> 
 <div class="sectionbody"> 
  <div class="sect2"> 
   <h3 id="查看依赖树">查看依赖树</h3> 
   <div class="paragraph"> 
    <p>查看依赖树是非常常用的，这里除了默认的文本输出，还可以使用outputType参数来指定格式如graphml,dot等，接着就可以可视化的展示依赖树了。</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-shell script" data-lang="shell script">mvn dependency:tree -DoutputType=graphml -DoutputFile=dependency.graphml</code></pre> 
    </div> 
   </div> 
  </div> 
  <div class="sect2"> 
   <h3 id="查看依赖使用情况">查看依赖使用情况</h3> 
   <div class="paragraph"> 
    <p>分析依赖使用与否的情况，貌似不太准确，参考就可以了。</p> 
   </div> 
   <div class="listingblock"> 
    <div class="content"> 
     <pre class="highlight"><code class="language-shell script" data-lang="shell script">mvn dependency:analyze</code></pre> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="结论">结论</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>整个Maven依赖管理以当前项目为中心分为2部分，当前项目以上部分适用继承合并pom.xml，当前项目以下的依赖部分适用传递依赖与最短申明距离的依赖协调机制。</p> 
  </div> 
  <div class="imageblock"> 
   <div class="content"> 
    <img src="https://www.reploop.org/blog/2021/09/images/deps-tree.svg" alt="项目树"> 
   </div> 
   <div class="title">
    Figure 6. Maven项目树
   </div> 
  </div> 
  <div class="paragraph"> 
   <p>通过以上分析，就能回答前面提出的2个问题，并且解决版本冲突的问题。</p> 
  </div> 
 </div> 
</div> 
<div class="sect1"> 
 <h2 id="参考">参考</h2> 
 <div class="sectionbody"> 
  <div class="ulist"> 
   <ul> 
    <li> <p>JRebel 2021 Java Developer Productivity Report, <a href="https://www.jrebel.com/resources/java-developer-productivity-report-2021" class="bare">https://www.jrebel.com/resources/java-developer-productivity-report-2021</a></p> </li> 
    <li> <p>Introduction to the Dependency Mechanism, <a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html" class="bare">https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html</a></p> </li> 
    <li> <p>Spring with Maven BOM, <a href="https://www.baeldung.com/spring-maven-bom" class="bare">https://www.baeldung.com/spring-maven-bom</a></p> </li> 
   </ul> 
  </div> 
 </div> 
</div></p>

	<hr />
	
	<p><a href="archive.html">点击查看更多文章</a>.</p>

		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2020 | Mixed with <a href="http://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="http://jbake.org">JBake v2.7.0.4</a></p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="js/jquery-1.11.1.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/prettify.js"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
  </body>
</html>